
/******************************************************************************/
/*! @addtogroup Audio
*  @{
******************************************************************************/
/******************************************************************************/
/*!
* @file    drv_audio.h
*
* @brief   This file specifies the APIs provided to control audio input device.
*
* @note     Copyright (c) 2007 Sunplus Technology Co., Ltd. \n
*          All rights reserved.
*
********************************************************************************/

#ifndef _DRV_AUDIO_H_
#define _DRV_AUDIO_H_

#define SPV9107_DEVELOP_VERSION
#define NEW_OUTPUT_CONFIG_METHOD  //To do:should remove this compile option

/*******************************************************************************
* Header include
******************************************************************************/
//#ifdef SPV9107_DEVELOP_VERSION
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/io.h>

#include <asm/mach-spv9200/regmap_9200.h>
#include <asm/mach-spv9200/spv9200.h>
#include <asm/mach-spv9200/types.h>

#include "hw_ssd_def.h"
//#else
//#include "platform/ic_9200/hw_public.h"
//#endif

/*******************************************************************************
* constant
******************************************************************************/
/*enable/disable log message*/
//#define DTV_DRV_AUDIO_DEBUG_MSG_ENABLE//               0//1
#undef DRV_AUDIO_DEBUG_MSG_ENABLE//               0//1
//#define DTV_DRV_AUDIO_WARNING_MSG_ENABLE//             0//1
#undef DRV_AUDIO_WARNING_MSG_ENABLE//             0//1
//#define DTV_DRV_AUDIO_ERROR_MSG_ENABLE//               0//1
#undef DRV_AUDIO_ERROR_MSG_ENABLE//               0//1

#define DRV_AUD_PGA_MIN	(-25)
#define DRV_AUD_PGA_MAX	(6)
#define DRV_AUD_SIF_AGC_MIN	(-6)
#define DRV_AUD_SIF_AGC_MAX	(25)
//#define DTV_DRV_AUD_PGA_GAIN_CONTROL_BOUNDARY	(-2)

//#define INICAM_QPSK_PLUS_0_DEGREE_CARRIER2_DEFAULT                  0x7D000
#define INICAM_QPSK_PLUS_90_DEGREE_CARRIER2_MINUS_90_POINT_72KHZ    0x7A8667
#define INICAM_QPSK_MINUS_90_DEGREE_CARRIER2_PLUS_90_POINT_72KHZ    0x7DF735
/*******************************************************************************
* enumeration
******************************************************************************/
typedef enum
{
	DRV_AUD_SIF_ADC_POWER_ON	= 0,
	DRV_AUD_SIF_ADC_POWER_OFF,
	DRV_AUD_LINE_IN_ADC_POWER_ON,
	DRV_AUD_LINE_IN_ADC_POWER_OFF,
	DRV_AUD_DAC_VCOM_ON,
	DRV_AUD_DAC_VCOM_OFF,
	DRV_AUD_DAC_VRT_ON,
	DRV_AUD_DAC_VRT_OFF,
	DRV_AUD_DAC_POWER_ON,
	DRV_AUD_DAC_POWER_OFF,
	DRV_AUD_DAC0_POWER_ON,
	DRV_AUD_DAC0_POWER_OFF,
	DRV_AUD_DAC1_POWER_ON,
	DRV_AUD_DAC1_POWER_OFF,
	DRV_AUD_DAC2_POWER_ON,
	DRV_AUD_DAC2_POWER_OFF,
	DRV_AUD_ALL_POWER_ON,
	DRV_AUD_ALL_POWER_OFF,
} DRV_AudPowerControl_t;

/**
*  @brief IF Audio standard
*   This is direct mapping to the definition of register value.
*   If the register value[REG_Ssd_stdres] is changed, then this sequence need
*   to be changed, too.
*/
typedef enum
{
    DRV_AUD_STANDARD_FAIL                           = 0,
    DRV_AUD_STANDARD_BG,
    DRV_AUD_STANDARD_DK,
    DRV_AUD_STANDARD_M,
    DRV_AUD_STANDARD_BG_A2,
    DRV_AUD_STANDARD_BG_NICAM,
    DRV_AUD_STANDARD_DK_A2_1,
    DRV_AUD_STANDARD_DK_A2_2,
    DRV_AUD_STANDARD_DK_A2_3,
    DRV_AUD_STANDARD_DK_NICAM,
    DRV_AUD_STANDARD_L_NICAM,
    DRV_AUD_STANDARD_I_NICAM,
    DRV_AUD_STANDARD_M_KOREA,
    DRV_AUD_STANDARD_M_BTSC,
    DRV_AUD_STANDARD_M_EIAJ,
    DRV_AUD_STANDARD_FM_10_7_IF_50_US,
    DRV_AUD_STANDARD_FM_10_7_IF_75_US,
    DRV_AUD_STANDARD_FM_SELECTABLE_IF_50_US,        /* Need to check ?? */
    DRV_AUD_STANDARD_FM_SELECTABLE_IF_75_US,        /* Need to check ?? */
    DRV_AUD_STANDARD_BUSY                           = 31,
} DRV_AudStandard_t;

/**
*  @brief IF Audio standard selection
*/
typedef enum
{
    DRV_AUD_AUTO_BG_GROUP		= (0x01),	/* B/G(H) (2 possible stereo standards)  5.5 MHz */
    DRV_AUD_AUTO_DK_GROUP		= (0x02),	/* D/K/K'(4 possible stereo standards)   6.5 MHz */
    DRV_AUD_AUTO_L_GROUP		= (0x04), 	/* L/L'                                  6.5 MHz */
    DRV_AUD_AUTO_I_GROUP		= (0x08), 	/* I                                     6.0 MHz */
    DRV_AUD_AUTO_M_GROUP		= (0x10), 	/* M(Korea A2 BTSC or EIAJ)              4.5 MHz */
//    DTV_DRV_AUD_AUTO_BGDKI_GROUP	= (DTV_DRV_AUD_AUTO_BG_GROUP|DTV_DRV_AUD_AUTO_DK_GROUP|DTV_DRV_AUD_AUTO_I_GROUP),
//    DTV_DRV_AUD_AUTO_BGDKIM_GROUP	= (DTV_DRV_AUD_AUTO_BG_GROUP|DTV_DRV_AUD_AUTO_DK_GROUP|DTV_DRV_AUD_AUTO_I_GROUP|DTV_DRV_AUD_AUTO_M_GROUP),
//    DTV_DRV_AUD_AUTO_ALL_GROUP		= (0x1f), 	/* all mask bits */
} DRV_AudAutoStandardGroup_t;

typedef enum
{
	DRV_AUD_STATIC_BG									= DRV_AUD_STANDARD_BG,
	DRV_AUD_STATIC_DK									= DRV_AUD_STANDARD_DK,
	DRV_AUD_STATIC_M									= DRV_AUD_STANDARD_M,
    DRV_AUD_STATIC_BG_A2								= REG_SSD_STDSEL_VALUE_B_G_A2,
    DRV_AUD_STATIC_BG_NICAM								= REG_SSD_STDSEL_VALUE_B_G_NICAM,
    DRV_AUD_STATIC_DK_A2_1								= REG_SSD_STDSEL_VALUE_D_K_A2_1,
    DRV_AUD_STATIC_DK_A2_2								= REG_SSD_STDSEL_VALUE_D_K_A2_2,
    DRV_AUD_STATIC_DK_A2_3								= REG_SSD_STDSEL_VALUE_D_K_A2_3,
    DRV_AUD_STATIC_DK_NICAM								= REG_SSD_STDSEL_VALUE_D_K_NICAM,
    DRV_AUD_STATIC_L_NICAM								= REG_SSD_STDSEL_VALUE_L_NICAM_L,
    DRV_AUD_STATIC_I_NICAM								= REG_SSD_STDSEL_VALUE_I_NICAM,
    DRV_AUD_STATIC_M_KOREA								= REG_SSD_STDSEL_VALUE_M_KOREA,
    DRV_AUD_STATIC_M_BTSC								= REG_SSD_STDSEL_VALUE_M_BTSC,
    DRV_AUD_STATIC_M_EIAJ								= REG_SSD_STDSEL_VALUE_M_EIAJ,
	DRV_AUD_STATIC_FM_RADIO_10_7_MHZ_50_US_DEMPHASIS	= REG_SSD_STDSEL_VALUE_FM_RADIO_IF_10_7_MHZ_50_US_DEEMPHASIS,
	DRV_AUD_STATIC_FM_RADIO_10_7_MHZ_75_US_DEMPHASIS	= REG_SSD_STDSEL_VALUE_FM_RADIO_IF_10_7_MHZ_75_US_DEEMPHASIS,
	DRV_AUD_STATIC_FM_RADIO_SELECTABLE_50_US_DEMPHASIS	= REG_SSD_STDSEL_VALUE_FM_RADIO_SELECTABLE_IF_50_US_DEEMPHASIS,
	DRV_AUD_STATIC_FM_RADIO_SELECTABLE_75_US_DEMPHASIS	= REG_SSD_STDSEL_VALUE_FM_RADIO_SELECTABLE_IF_75_US_DEEMPHASIS,
} DRV_AudStaticStandardSelection_t;

typedef enum
{
    DRV_AUD_NICAM_QPSK_ROTATE_0_DEGREE          = 0,//REG_SSD_QPSK_ROTATION_V_DEFAULT_,
    DRV_AUD_NICAM_QPSK_ROTATE_PLUS_90_DEGREE    ,//= REG_SSD_QPSK_ROTATION_V_POS90_,
    DRV_AUD_NICAM_QPSK_ROTATE_MINUS_90_DEGREE   ,//= REG_SSD_QPSK_ROTATION_V_NEW90_,
    DRV_AUD_NICAM_QPSK_ROTATE_MAX               ,//= DTV_DRV_AUD_NICAM_QPSK_ROTATE_MINUS_90_DEGREE,
} DRV_AudNICAMRotateAngle_t;

/**
*  @brief DEMDEC reset action
*/
typedef enum
{
    DRV_AUD_DEMDEC_RESET_STAR		= REG_SSD_REST_VALUE_RUNNING,
    DRV_AUD_DEMDEC_RESET_RELEASE	= REG_SSD_REST_VALUE_RESTART,
} DRV_AudDEMDECResetAction_t;


/**
*  @brief BTSC DBX mode selection
*/
typedef enum
{
    DRV_AUD_STEREO_MODE,
    DRV_AUD_SAP_MODE,
} DRV_AudBTSCDBXMode_t;

/**
*  @brief
*/
typedef enum
{
    DRV_AUD_DIGITAL_DEEMPHASIS_NONE                 = REG_SSD_DIGIN_DEEM_VALUE_NO_DEEMPHASIS,
    /* no deemphasis       */
    DRV_AUD_DIGITAL_DEEMPHASIS_50_15_US_32_KHZ      = REG_SSD_DIGIN_DEEM_VALUE_50_15_US_DEEMPHASIS_FOR_32_KHZ_SAMPLE_RATE,
    /* 50/15 us deemphasis */
    DRV_AUD_DIGITAL_DEEMPHASIS_50_15_US_44_1_KHZ    = REG_SSD_DIGIN_DEEM_VALUE_50_15_US_DEEMPHASIS_FOR_44_1_KHZ_SAMPLE_RATE,
    /* 50/15 us deemphasis */
    DRV_AUD_DIGITAL_DEEMPHASIS_50_15_US_48_KHZ      = REG_SSD_DIGIN_DEEM_VALUE_50_15_US_DEEMPHASIS_FOR_48_KHZ_SAMPLE_RATE,
    /* 50/15 us deemphasis */
    DRV_AUD_DIGITAL_DEEMPHASIS_J17_32_KHZ           = REG_SSD_DIGIN_DEEM_VALUE_J17_DEEMPHASIS_FOR_32_KHZ_SAMPLE_RATE,
    /* J17 deemphasis      */
    DRV_AUD_DIGITAL_DEEMPHASIS_J17_44_1_KHZ         = REG_SSD_DIGIN_DEEM_VALUE_J17_DEEMPHASIS_FOR_44_1_KHZ_SAMPLE_RATE,
    /* J17 deemphasis      */
    DRV_AUD_DIGITAL_DEEMPHASIS_J17_48_KHZ           = REG_SSD_DIGIN_DEEM_VALUE_J17_DEEMPHASIS_FOR_48_KHZ_SAMPLE_RATE,
    /* J17 deemphasis      */
} DRV_AudDigitalDeemphasis_t;

/**
*  @brief enum for divider setting for digital audio input
*/
typedef enum
{
    DRV_AUD_DIGITAL_DIVIDER_1X_FS_MODE          = 0,
    /* sample rate < 48 kHz          */
    DRV_AUD_DIGITAL_DIVIDER_2X_FS_MODE,
    /* 48 kHz < sample rate < 96 kHz */
    DRV_AUD_DIGITAL_DIVIDER_4X_FS_MODE,
    /* sample rate > 96 kHz          */
} DRV_AudDigitalDivider_t;

/**
*  @brief enum for PROCESS_CHANNEL
*/
typedef enum
{
    DRV_AUD_PROCESS_PATH_MAIN            = 0,
    DRV_AUD_PROCESS_PATH_SUBWOOFER,
    DRV_AUD_PROCESS_PATH_CENTER,
    DRV_AUD_PROCESS_PATH_SURROUND,
    DRV_AUD_PROCESS_PATH_AUX1,
    DRV_AUD_PROCESS_PATH_AUX2,
    DRV_AUD_PROCESS_PATH_AUX3,
} DRV_AudProcessPath_t;


/**
*  @brief enum for Input Channel
*/
typedef enum
{
    DRV_AUD_INPUT_SIF0	= 0,
//    DTV_DRV_AUD_INPUT_SIF1	= REG_CTRL_SIFADC_MUX_VALUE_SIFAIN1,
} DRV_AudIFInput_t;

typedef enum
{

    DRV_AUD_INPUT_ADC0,
    DRV_AUD_INPUT_ADC1,
    DRV_AUD_INPUT_ADC2,
    DRV_AUD_INPUT_ADC3,
    DRV_AUD_INPUT_MPEG_DSP_PCM,
}      DRV_AudADCInput_t;


typedef enum
{
    DRV_AUD_INPUT_HDMI_I2S          = 0,
    DRV_AUD_INPUT_HDMI_SPDIF,
    DRV_AUD_INPUT_MPEG_DSP_I2S,
    DRV_AUD_INPUT_EXTERNAL_SPDIF,
} DRV_AudDigitalInput_t;

/**
*  @brief enum for SSD source
*/
typedef enum
{
    DRV_AUD_SRC_1       = 0,
    DRV_AUD_SRC_2,
} DRV_AudSRCPath_t;

/**
*  @brief enum for Mute channel
*/
typedef enum
{
    DRV_AUD_MUTE_PATH_MAIN               = 0,
    DRV_AUD_MUTE_PATH_MAIN_LEFT,
    DRV_AUD_MUTE_PATH_MAIN_RIGHT,
    DRV_AUD_MUTE_PATH_SUBWOOFER,
    DRV_AUD_MUTE_PATH_CENTER,
    DRV_AUD_MUTE_PATH_SURROUND,
    DRV_AUD_MUTE_PATH_AUX1,
    DRV_AUD_MUTE_PATH_AUX2,
    DRV_AUD_MUTE_PATH_AUX3,
    DRV_AUD_MUTE_PATH_ALL
} DRV_AudMutePath_t;

/**
*  @brief enum for SSD source channel value
*/
typedef enum
{
    DRV_AUD_SRC_DISABLED                    = 0,
    DRV_AUD_SRC_DEC,
    DRV_AUD_SRC_MONO_SAP,
    DRV_AUD_SRC_DIGITAL_AUDIO_INPUT,
} DRV_AudSRCSource_t;

/**
*  @brief enum for SSD digital matrix
*/
typedef enum
{
    DRV_AUD_DIGITAL_MATRIX_STEREO_AUTO_OFF          = 0,
    DRV_AUD_DIGITAL_MATRIX_MONO_AUTO_OFF,
    DRV_AUD_DIGITAL_MATRIX_LANGUAGEA_AUTO_OFF,
    DRV_AUD_DIGITAL_MATRIX_LANGUAGEB_AUTO_OFF,
    DRV_AUD_DIGITAL_MATRIX_SWAP_AUTO_OFF,
    DRV_AUD_DIGITAL_MATRIX_UNUSED,
    DRV_AUD_DIGITAL_MATRIX_LANGUAGEA_AUTO_ON,
    DRV_AUD_DIGITAL_MATRIX_LANGUAGEB_AUTO_ON,
} DRV_AudDigitalMatrix_t;


/**
*  @brief enum for SSD output Source
*/
typedef enum
{
    DRV_AUD_SSD_OUTPUT_SOURCE_MAIN_L               = 0,
    DRV_AUD_SSD_OUTPUT_SOURCE_MAIN_R,
    DRV_AUD_SSD_OUTPUT_SOURCE_SUBWOOFER,
    DRV_AUD_SSD_OUTPUT_SOURCE_CENTER,
    DRV_AUD_SSD_OUTPUT_SOURCE_SURROUND,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX1_L,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX1_R,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX2_L,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX2_R,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX3_L,
    DRV_AUD_SSD_OUTPUT_SOURCE_AUX3_R,
    DRV_AUD_SSD_OUTPUT_SOURCE_MAIN_SUM,
    DRV_AUD_SSD_OUTPUT_SOURCE_DIGITAL_SILENCE,
} DRV_AudSSDOutputSource_t;

#ifdef NEW_OUTPUT_CONFIG_METHOD
/**
*  @brief enum for output crossbar destination
*/
typedef enum
{
    DRV_AUD_OUTPUT_NULL     = 0,
    DRV_AUD_OUTPUT_DAC0,
    DRV_AUD_OUTPUT_DAC1,
    DRV_AUD_OUTPUT_DAC2,
    DRV_AUD_OUTPUT_I2S_SD0,
    DRV_AUD_OUTPUT_I2S_SD1,
    DRV_AUD_OUTPUT_I2S_SD2,
    DRV_AUD_OUTPUT_SPDIF,
} DRV_AudOutputPath_t;

/**
*  @brief enum for output crossbar source
*/
typedef enum
{//I2S sources must map to register values
    DRV_AUD_I2S_HDMI_OUTPUT_SD0     = REG_SSD_OS_DAC0_V_I2S_INPUT_FROM_HDMI_IS_OUTPUT_VIA_SD0,
    DRV_AUD_I2S_SSD_OUTPUT_SD0      = REG_SSD_OS_DAC0_V_SD0_FROM_SSD_IS_OUTPUT_VIA_SD0,
    DRV_AUD_I2S_SSD_OUTPUT_SD1      = REG_SSD_OS_DAC0_V_SD1_FROM_SSD_IS_OUTPUT_VIA_SD0,
    DRV_AUD_I2S_SSD_OUTPUT_SD2      = REG_SSD_OS_DAC0_V_SD2_FROM_SSD_IS_OUTPUT_VIA_SD0,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD0  = REG_SSD_OS_DAC0_V_DSP_I2S_DATA_0__FROM_DVD_DSP_IS_OUTPUT__4,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD1  = REG_SSD_OS_DAC0_V_DSP_I2S_DATA_1__FROM_DVD_DSP_IS_OUTPUT__5,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD2  = REG_SSD_OS_DAC0_V_DSP_I2S_DATA_2__FROM_DVD_DSP_IS_OUTPUT__6,
    DRV_AUD_SPDIF_EXTERNAL_INPUT,
    DRV_AUD_SPDIF_HDMI_OUTPUT,
    DRV_AUD_SPDIF_SSD_OUTPUT,
    DRV_AUD_SPDIF_DVD_DSP_OUTPUT,
    DRV_AUD_OUTPUT_MAX,
} DRV_AudOutputCrossbarSource_t;

#else
/**
*  @brief enum for output crossbar destination
*/
typedef enum
{
    DRV_AUD_OUTPUT_DAC0     = 0,
    DRV_AUD_OUTPUT_DAC1,
    DRV_AUD_OUTPUT_DAC2,
    DRV_AUD_OUTPUT_I2S_SD0,
    DRV_AUD_OUTPUT_I2S_SD1,
    DRV_AUD_OUTPUT_I2S_SD2,
    DRV_AUD_OUTPUT_SPDIF,
} DRV_AudOutputCrossbarDestination_t;

/**
*  @brief enum for output crossbar source
*/
typedef enum
{//I2S sources must map to register values
    DRV_AUD_I2S_HDMI_OUTPUT_SD0     = REG_SSD_OS_DAC0_V_HDMI_,
    DRV_AUD_I2S_SSD_OUTPUT_SD0      = REG_SSD_OS_DAC0_V_SD0_,
    DRV_AUD_I2S_SSD_OUTPUT_SD1      = REG_SSD_OS_DAC0_V_SD1_,
    DRV_AUD_I2S_SSD_OUTPUT_SD2      = REG_SSD_OS_DAC0_V_SD2_,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD0  = REG_SSD_OS_DAC0_V_DSP0_,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD1  = REG_SSD_OS_DAC0_V_DSP1_,
    DRV_AUD_I2S_DVD_DSP_OUTPUT_SD2  = REG_SSD_OS_DAC0_V_DSP2_,
    DRV_AUD_SPDIF_EXTERNAL_INPUT,
    DRV_AUD_SPDIF_HDMI_OUTPUT,
    DRV_AUD_SPDIF_SSD_OUTPUT,
    DRV_AUD_SPDIF_DVD_DSP_OUTPUT,
} DRV_AudOutputCrossbarSource_t;

/**
*  @brief enum for SSD output channel
*/
typedef enum
{
    DRV_AUD_SSD_OUTPUT_DAC0          = 0,
    DRV_AUD_SSD_OUTPUT_DAC1,
    DRV_AUD_SSD_OUTPUT_DAC2,
    DRV_AUD_SSD_OUTPUT_I2S0,
    DRV_AUD_SSD_OUTPUT_I2S1,
    DRV_AUD_SSD_OUTPUT_I2S2,
    DRV_AUD_SSD_OUTPUT_SPDIF,
} DRV_AudSSDOutputPath_t;
#endif

/**
*  @brief enum for I2S format
*/
typedef enum
{
    DRV_AUD_I2S_OUTPUT_PHILIPS24BIT		= 0,
    DRV_AUD_I2S_OUTPUT_SONY24BIT,
    DRV_AUD_I2S_OUTPUT_JAPANESE24BIT,
} DRV_AudI2SOutputFormat_t;

/**
*  @brief enum for SSD center and surround path Source
*/
typedef enum
{
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_ADC_LEFT    = 0,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_ADC_RIGHT,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_SRC1_LEFT,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_SRC1_RIGHT,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_SRC2_LEFT,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_SRC2_RIGHT,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_NOISE,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_SILENCE,
    DRV_AUD_CENTER_SURROUND_PATH_SOURCE_BEEPER,
} DRV_AudCenterSurroundSource_t;

typedef enum
{
    DRV_AUD_MAIN_AUX_PATH_SOURCE_ADC            = 0,
    DRV_AUD_MAIN_AUX_PATH_SOURCE_SRC1,
    DRV_AUD_MAIN_AUX_PATH_SOURCE_SRC2,
    DRV_AUD_MAIN_AUX_PATH_SOURCE_NOISE_SILENCE,
    DRV_AUD_MAIN_AUX_PATH_SOURCE_BEEPER,
} DRV_AudMainAUXSource_t;

/**
*  @brief enum Main Path Mixer
*/
typedef enum
{
//    DRV_AUD_MAIN_PATH_MIXER_BEEPER                  = REG_SSD_MIXERSEL_VALUE_BEEPER_OUTPUT,
    DRV_AUD_MAIN_PATH_MIXER_PROCESSED_SURROUND      = REG_SSD_MIXERSEL_VALUE_PROCESSED_SURROUND,
    DRV_AUD_MAIN_PATH_MIXER_UNPROCESSED_SURROUND    = REG_SSD_MIXERSEL_VALUE_UN_PROCESSED_SURROUND,
    DRV_AUD_MAIN_PATH_MIXER_SILENCE                 = REG_SSD_MIXERSEL_VALUE_SILENCE,
} DRV_AudMainPathMixer_t;

/**
*  @brief enum for Sound Modes
*/
#if 1
typedef enum
{
    DRV_AUD_EFFECT_MODE_DEFAULT                                 = REG_SSD_SNDMOD_VALUE_MONO_STEREO_DEFAULT,
//    DRV_AUD_EFFECT_MODE_VDSII422                                = REG_SSD_SNDMOD_VALUE_VDSII422,
//    DRV_AUD_EFFECT_MODE_VDSII423                                = REG_SSD_SNDMOD_VALUE_VDSII423,
//    DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_DPL                     = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_DPL,
    DRV_AUD_EFFECT_MODE_NOISE_SEQUENCING                        = REG_SSD_SNDMOD_VALUE_NOISE_SEQUENCING,
//    DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_PASSIVE_MATRIX          = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_PASSIVE_MATRIX,
    DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_XT_PASSIVE_MATRIX       = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_XT_PASSIVE_MATRIX,
    DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_XT_DPL                  = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_XT_DPL,
//    DRV_AUD_EFFECT_MODE_NVS522                                  = REG_SSD_SNDMOD_VALUE_NVS522,
//    DRV_AUD_EFFECT_MODE_NVS523                                  = REG_SSD_SNDMOD_VALUE_NVS523,
} DRV_AudEffectMode_t;
#else
typedef enum
{
    DTV_DRV_AUD_EFFECT_MODE_DEFAULT                                 = REG_SSD_SNDMOD_VALUE_MONO_STEREO_DEFAULT,
    DTV_DRV_AUD_EFFECT_MODE_PSEUDO_HALL                             = REG_SSD_SNDMOD_VALUE_MONO_STEREO_HALL,
    DTV_DRV_AUD_EFFECT_MODE_PSEUDO_MATRIX                           = REG_SSD_SNDMOD_VALUE_MONO_STEREO_MATRIX,
//    DTV_DRV_AUD_EFFECT_MODE_RESERVED1,
//    DTV_DRV_AUD_EFFECT_MODE_RESERVED2,
//    DTV_DRV_AUD_EFFECT_MODE_RESERVED3,
    DTV_DRV_AUD_EFFECT_MODE_VDSII422                                = REG_SSD_SNDMOD_VALUE_VDSII422,
    DTV_DRV_AUD_EFFECT_MODE_VDSII423                                = REG_SSD_SNDMOD_VALUE_VDSII423,
    DTV_DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_DPL                     = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_DPL,
    DTV_DRV_AUD_EFFECT_MODE_NOISE_SEQUENCING                        = REG_SSD_SNDMOD_VALUE_NOISE_SEQUENCING,
    DTV_DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_PASSIVE_MATRIX          = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_PASSIVE_MATRIX,
    DTV_DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_XT_PASSIVE_MATRIX       = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_XT_PASSIVE_MATRIX,
    DTV_DRV_AUD_EFFECT_MODE_SRS_TRUSURROUND_XT_DPL                  = REG_SSD_SNDMOD_VALUE_SRS_TRUSURROUND_XT_DPL,
} DTV_DRV_AudEffectMode_t;
#endif

/**
*  @brief enum for Spatial Effect
*/
typedef enum
{
    DRV_AUD_SPATIAL_EFFECT_OFF                = REG_SSD_SOMOCTRL_VALUE_OFF,
    DRV_AUD_SPATIAL_EFFECT_I_STEREO           = REG_SSD_SOMOCTRL_VALUE_I_STEREO,
    DRV_AUD_SPATIAL_EFFECT_I_MONO             = REG_SSD_SOMOCTRL_VALUE_I_MONO,
    DRV_AUD_SPATIAL_EFFECT_SRS_SPATIALIZER    = REG_SSD_SOMOCTRL_VALUE_SRS_SPATIALIZER,
    DRV_AUD_SPATIAL_EFFECT_AUTO_I_STEREO_I_MONO,
} DRV_AudSpatialEffect_t;

/**
*  @brief enum for I Sound Mode
*/
typedef enum
{
    DRV_AUD_ISOUND_MODE_MANUAL  = 0,
    DRV_AUD_ISOUND_MODE_AUTO,
} DRV_AudISoundMode_t;

/**
*  @brief enum for SRS Spatializer Selector
*/
typedef enum
{
    DRV_AUD_SPATSEL_3D_SOUND    = 0,
    DRV_AUD_SPATSEL_WOW,
} DRV_AudSRSSpatializer_t;

/**
*  @brief enum for Bass Feature Control
*/
typedef enum
{
    DRV_AUD_BASS_FEATURECONTROL_OFF            = REG_SSD_BASSFEATURECTRL_VALUE_DBB_DVB_AND_BBE_OFF,
    DRV_AUD_BASS_FEATURECONTROL_DBB_MAIN       = REG_SSD_BASSFEATURECTRL_VALUE_DBB_MAIN_CHANNEL_ON,
    DRV_AUD_BASS_FEATURECONTROL_DVB_MAIN       = REG_SSD_BASSFEATURECTRL_VALUE_DVB_MAIN_CHANNEL_ON,
    DRV_AUD_BASS_FEATURECONTROL_DBB_SUBWOOFER  = REG_SSD_BASSFEATURECTRL_VALUE_DBB_SUBWOOFER_CHANNEL_ON,
    DRV_AUD_BASS_FEATURECONTROL_DVB_SUBWOOFER  = REG_SSD_BASSFEATURECTRL_VALUE_DVB_SUBWOOFER_CHANNEL_ON,
 //   DRV_AUD_BASS_FEATURECONTROL_BBE            = REG_SSD_BASSFEATURECTRL_VALUE_BBE_ON,
} DRV_AudBassFeatureControl_t;

/**
*  @brief enum for Subwoofer Mode
*/
typedef enum
{
    DRV_AUD_NORMAL_SUBWOOFER_MODE       = 0,
    DRV_AUD_ECONOMIC_SUBWOOFER_MODE,
} DRV_AudSubwooferMode_t;

/**
*  @brief enum for AVL mode
*/
typedef enum
{
    DRV_AUD_AVL_MODE_OFF    = REG_SSD_AVLMOD_VALUE_OFF,
    DRV_AUD_AVL_MODE_20MS   = REG_SSD_AVLMOD_VALUE_VERY_SHORT_DECAY_20_MS,
    DRV_AUD_AVL_MODE_02S    = REG_SSD_AVLMOD_VALUE_SHORT_DECAY_2_SEC,
    DRV_AUD_AVL_MODE_04S    = REG_SSD_AVLMOD_VALUE_MEDIUM_DECAY_4_SEC,
    DRV_AUD_AVL_MODE_08S    = REG_SSD_AVLMOD_VALUE_LONG_DECAY_8_SEC,
    DRV_AUD_AVL_MODE_16S    = REG_SSD_AVLMOD_VALUE_VERY_LONG_DECAY_16_SEC,
} DRV_AudAVLMode_t;

/**
*  @brief enum for Main Loudness None Attack Volume Level
*/
typedef enum
{
    DRV_AUD_MAINLOUDNESS_VOLUME_MINUS_15DB  = 0,
    DRV_AUD_MAINLOUDNESS_VOLUME_MINUS_12DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_MINUS_09DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_MINUS_06DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_MINUS_03DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_00DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_03DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_06DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_09DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_12DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_15DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_18DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_21DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_24DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_27DB,
    DRV_AUD_MAINLOUDNESS_VOLUME_PLUS_30DB,
} DRV_AudMainLoudnessVolumeLevel_t;

/**
*  @brief enum for Mux Type
*/
typedef enum
{
    DRV_AUD_DLU_ADC_INPUT =   0,
    DRV_AUD_DLU_DIGITAL_INPUT,
} DRV_AudDLUSource_t;

/**
*  @brief enum for Clip Management
*/
typedef enum
{
    DRV_AUD_CLIP_MANAGEMENT_OFF                     = REG_SSD_CLIPMANAGE_VALUE_CLIP_MANAGEMENT_OFF_DEFAULT,
    DRV_AUD_CLIP_MANAGEMENT_STATIC_VOLUME_MODE      = REG_SSD_CLIPMANAGE_VALUE_STATIC_VOLUME_MODE,
    DRV_AUD_CLIP_MANAGEMENT_STATIC_CONTROL_MODE     = REG_SSD_CLIPMANAGE_VALUE_STATIC_CONTROL_MODE,
    DRV_AUD_CLIP_MANAGEMENT_DYNAMIC_CONTROL_MODE    = REG_SSD_CLIPMANAGE_VALUE_DYNAMIC_CONTROL_MODE,
    DRV_AUD_CLIP_MANAGEMENT_DYNAMIC_VOLUME_MODE     = REG_SSD_CLIPMANAGE_VALUE_DYNAMIC_VOLUME_MODE,
} DRV_AudClipManagementMode_t;

/**
*  @brief enum for Clip Management DVM peak detection selection
*/
typedef enum
{
    DRV_AUD_DVM_PEAK_DETECTION_SELECT_MAIN                  = 0,
    DRV_AUD_DVM_PEAK_DETECTION_SELECT_MAIN_CENTER_SUBWOOFER,
} DRV_AudDVMPeakDetectionSelection_t;

/**
*  @brief enum for Bass Management Mode
*/
typedef enum
{
    DRV_AUD_BASSMANAGEMENT_OFF          = REG_SSD_BAMAMO_VALUE_OFF_WIDE_CENTRE_MODE,
    DRV_AUD_BASSMANAGEMENT_TYPE1_MODE   = REG_SSD_BAMAMO_VALUE_TYP1_CONFIGURATION_NORMAL_CENTRE_MODE,
    DRV_AUD_BASSMANAGEMENT_TYPE2_MODE   = REG_SSD_BAMAMO_VALUE_TYP2_CONFIGURATION_NORMAL_CENTRE_MODE,
} DRV_AudBassManagementMode_t;

/**
*  @brief enum for Bass Management Filter Characteristic
*/
typedef enum
{
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_050HZ = REG_SSD_BAMAFC_VALUE_50_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_060HZ = REG_SSD_BAMAFC_VALUE_60_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_070HZ = REG_SSD_BAMAFC_VALUE_70_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_080HZ = REG_SSD_BAMAFC_VALUE_80_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_090HZ = REG_SSD_BAMAFC_VALUE_90_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_100HZ = REG_SSD_BAMAFC_VALUE_100_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_110HZ = REG_SSD_BAMAFC_VALUE_110_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_120HZ = REG_SSD_BAMAFC_VALUE_120_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_130HZ = REG_SSD_BAMAFC_VALUE_130_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_140HZ = REG_SSD_BAMAFC_VALUE_140_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_150HZ = REG_SSD_BAMAFC_VALUE_150_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_200HZ = REG_SSD_BAMAFC_VALUE_200_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_250HZ = REG_SSD_BAMAFC_VALUE_250_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_300HZ = REG_SSD_BAMAFC_VALUE_300_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_350HZ = REG_SSD_BAMAFC_VALUE_350_HZ,
    DRV_AUD_BASSMANAGEMENT_FILTER_CHARACTERISTIC_400HZ = REG_SSD_BAMAFC_VALUE_400_HZ,
} DRV_AudBassManagementFilterCharacteristic_t;

/**
*  @brief enum for VDSII Effect Level
*/
typedef enum
{
    DRV_AUD_VDSII_EFFECT_LEVEL_000_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_0,
    DRV_AUD_VDSII_EFFECT_LEVEL_020_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_20,
    DRV_AUD_VDSII_EFFECT_LEVEL_040_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_40,
    DRV_AUD_VDSII_EFFECT_LEVEL_060_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_60,
    DRV_AUD_VDSII_EFFECT_LEVEL_080_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_80,
    DRV_AUD_VDSII_EFFECT_LEVEL_100_PERCENT	= REG_SSD_VDSMIXLEV_VALUE_100,
} DRV_AudVDSIIEffectLevel_t;

/**
*  @brief enum for VDSII Balance Control
*/
typedef enum
{
    DRV_AUD_VDSII_BALANCE_LEFT		= REG_SSD_VDSIIBALANCE_VALUE_LEFT,
    DRV_AUD_VDSII_BALANCE_CENTER	= REG_SSD_VDSIIBALANCE_VALUE_CENTER,
    DRV_AUD_VDSII_BALANCE_RIGHT		= REG_SSD_VDSIIBALANCE_VALUE_RIGTH,
} DRV_AudVDSIIBalanceControl_t;

/**
*  @brief enum for SRS TruSurround XT K Mode
*/
typedef enum
{
    DRV_AUD_SRSTSXT_MODE_K1_0_PASSIVE_MATRIX    = REG_SSD_TSXT_K_MODE_VALUE_K1_0,
    DRV_AUD_SRSTSXT_MODE_K2_0_PASSIVE_MATRIX    = REG_SSD_TSXT_K_MODE_VALUE_K2_0,
    DRV_AUD_SRSTSXT_MODE_K3_1_DPL               = REG_SSD_TSXT_K_MODE_VALUE_K3_1,
    DRV_AUD_SRSTSXT_MODE__PASSIVE_MATRIX        = REG_SSD_TSXT_K_MODE_VALUE_KPASSIVEMATRIX,
} DRV_AudSRSTrusurroundXT_K_Mode_t;

/**
*  @brief enum for SRS TruSurround XT Speaker Size
*/
typedef enum
{
    DRV_AUD_SRSTSXT_SPEAKERSIZE_040HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_40HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_060HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_60HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_100HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_100HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_150HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_150HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_200HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_200HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_250HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_250HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_300HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_300HZ,
    DRV_AUD_SRSTSXT_SPEAKERSIZE_400HZ    = REG_SSD_TSXT_SpeakerSize_VALUE_400HZ,
} DRV_AudSRSTrusurroundXT_SpeakerSize_t;

/**
*  @brief enum for SRS TruSurround XT TruBass Gain
*/
typedef enum
{
    DRV_AUD_SRSTSXT_TRUBASS_000_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_0,
    DRV_AUD_SRSTSXT_TRUBASS_007_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_7,
    DRV_AUD_SRSTSXT_TRUBASS_013_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_13,
    DRV_AUD_SRSTSXT_TRUBASS_020_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_20,
    DRV_AUD_SRSTSXT_TRUBASS_027_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_27,
    DRV_AUD_SRSTSXT_TRUBASS_033_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_33,
    DRV_AUD_SRSTSXT_TRUBASS_040_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_40,
    DRV_AUD_SRSTSXT_TRUBASS_046_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_46,
    DRV_AUD_SRSTSXT_TRUBASS_053_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_53,
    DRV_AUD_SRSTSXT_TRUBASS_060_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_60,
    DRV_AUD_SRSTSXT_TRUBASS_067_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_67,
    DRV_AUD_SRSTSXT_TRUBASS_073_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_73,
    DRV_AUD_SRSTSXT_TRUBASS_079_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_79,
    DRV_AUD_SRSTSXT_TRUBASS_086_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_86,
    DRV_AUD_SRSTSXT_TRUBASS_092_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_92,
    DRV_AUD_SRSTSXT_TRUBASS_100_PERCENT    = REG_SSD_TSXT_TruBass_GAIN_VALUE_100,
} DRV_AudSRSTrusurroundXT_TruBassGain_t;

/**
*  @brief enum for SRS TruSurround XT Dialog Clarity Gain
*/
typedef enum
{
    DRV_AUD_SRSTSXT_DIALOGCLARITY_000_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_0,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_007_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_7,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_013_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_13,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_020_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_20,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_027_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_27,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_033_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_33,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_040_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_40,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_046_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_46,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_053_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_53,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_060_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_60,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_067_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_67,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_073_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_73,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_079_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_79,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_086_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_86,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_092_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_92,
    DRV_AUD_SRSTSXT_DIALOGCLARITY_100_PERCENT    = REG_SSD_TSXT_DialogClarity_GAIN_VALUE_100,
} DRV_AudSRSTrusurroundXT_DialogClarityGain_t;

/**
*  @brief enum for I Sound Effect
*/
typedef enum
{
    DRV_AUD_ISOUND_INTENSITY_EFFECT_0    = REG_SSD_INSOEF_VALUE_1_MIN,
    DRV_AUD_ISOUND_INTENSITY_EFFECT_1    = REG_SSD_INSOEF_VALUE_2,
    DRV_AUD_ISOUND_INTENSITY_EFFECT_2    = REG_SSD_INSOEF_VALUE_3,
    DRV_AUD_ISOUND_INTENSITY_EFFECT_3    = REG_SSD_INSOEF_VALUE_4,
    DRV_AUD_ISOUND_INTENSITY_EFFECT_4    = REG_SSD_INSOEF_VALUE_5,
    DRV_AUD_ISOUND_INTENSITY_EFFECT_5    = REG_SSD_INSOEF_VALUE_6_MAX,
} DRV_AudISoundIntensityEffect_t;

/**
*  @brief enum for I Sound Fade Time
*/
typedef enum
{
    DRV_AUD_ISOUND_FADETIME_01_1_SEC   = 0,
    DRV_AUD_ISOUND_FADETIME_02_2_SEC,
    DRV_AUD_ISOUND_FADETIME_03_3_SEC,
    DRV_AUD_ISOUND_FADETIME_04_5_SEC,
    DRV_AUD_ISOUND_FADETIME_06_8_SEC,
    DRV_AUD_ISOUND_FADETIME_09_0_SEC,
    DRV_AUD_ISOUND_FADETIME_14_5_SEC,
    DRV_AUD_ISOUND_FADETIME_19_0_SEC,
    DRV_AUD_ISOUND_FADETIME_136_MSEC,
    DRV_AUD_ISOUND_FADETIME_272_MSEC,
    DRV_AUD_ISOUND_FADETIME_410_MSEC,
    DRV_AUD_ISOUND_FADETIME_546_MSEC,
    DRV_AUD_ISOUND_FADETIME_820_MSEC,
//    DTV_DRV_AUD_ISOUND_FADETIME_01_1_SEC,
    DRV_AUD_ISOUND_FADETIME_01_8_SEC,
    DRV_AUD_ISOUND_FADETIME_02_4SEC,
} DRV_AudISoundFadeTime_t;

/**
*  @brief enum for I Sound Detectot Time
*/
typedef enum
{
    DRV_AUD_ISOUND_DETECTORTIME_01SEC   = REG_SSD_ISOUNDDETTIME_VALUE_1SEC,
    DRV_AUD_ISOUND_DETECTORTIME_05SEC   = REG_SSD_ISOUNDDETTIME_VALUE_5SEC,
    DRV_AUD_ISOUND_DETECTORTIME_08SEC   = REG_SSD_ISOUNDDETTIME_VALUE_8SEC,
    DRV_AUD_ISOUND_DETECTORTIME_14SEC   = REG_SSD_ISOUNDDETTIME_VALUE_14SEC,
} DRV_AudISoundDetectorTime_t;

/**
*  @brief enum for SRS 3D Center
*/
typedef enum
{
    DRV_AUD_SRS3D_CENTER_MINUS_09DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_9DB,
    DRV_AUD_SRS3D_CENTER_MINUS_14DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_14DB,
    DRV_AUD_SRS3D_CENTER_MINUS_15DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_15DB,
    DRV_AUD_SRS3D_CENTER_MINUS_16DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_16DB,
    DRV_AUD_SRS3D_CENTER_MINUS_17DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_17DB,
    DRV_AUD_SRS3D_CENTER_MINUS_18DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_18DB,
    DRV_AUD_SRS3D_CENTER_MINUS_19DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_19DB,
    DRV_AUD_SRS3D_CENTER_MINUS_20DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_20DB,
    DRV_AUD_SRS3D_CENTER_MINUS_21DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_21DB,
    DRV_AUD_SRS3D_CENTER_MINUS_22DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_22DB,
    DRV_AUD_SRS3D_CENTER_MINUS_23DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_23DB,
    DRV_AUD_SRS3D_CENTER_MINUS_24DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_24DB,
    DRV_AUD_SRS3D_CENTER_MINUS_25DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_25DB,
    DRV_AUD_SRS3D_CENTER_MINUS_26DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_26DB,
    DRV_AUD_SRS3D_CENTER_MINUS_27DB  = REG_SSD_SRS3DCENTER_VALUE_MINUS_27DB,
    DRV_AUD_SRS3D_CENTER_MINUS_OFF   = REG_SSD_SRS3DCENTER_VALUE_OFF,
} DRV_AudSRS3DCenter_t;

/**
*  @brief enum for SRS 3D Space
*/
typedef enum
{
    DRV_AUD_SRS3D_SPACE_MINUS_04DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_4DB,
    DRV_AUD_SRS3D_SPACE_MINUS_05DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_5DB,
    DRV_AUD_SRS3D_SPACE_MINUS_06DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_6DB,
    DRV_AUD_SRS3D_SPACE_MINUS_07DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_7DB,
    DRV_AUD_SRS3D_SPACE_MINUS_08DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_8DB,
    DRV_AUD_SRS3D_SPACE_MINUS_09DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_9DB,
    DRV_AUD_SRS3D_SPACE_MINUS_10DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_10DB,
    DRV_AUD_SRS3D_SPACE_MINUS_11DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_11DB,
    DRV_AUD_SRS3D_SPACE_MINUS_12DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_12DB,
    DRV_AUD_SRS3D_SPACE_MINUS_13DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_13DB,
    DRV_AUD_SRS3D_SPACE_MINUS_14DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_14DB,
    DRV_AUD_SRS3D_SPACE_MINUS_15DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_15DB,
    DRV_AUD_SRS3D_SPACE_MINUS_16DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_16DB,
    DRV_AUD_SRS3D_SPACE_MINUS_17DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_17DB,
    DRV_AUD_SRS3D_SPACE_MINUS_18DB  = REG_SSD_SRS3DSPACE_VALUE_MINUS_18DB,
    DRV_AUD_SRS3D_SPACE_MINUS_OFF   = REG_SSD_SRS3DSPACE_VALUE_OFF,
} DRV_AudSRS3DSpace_t;

/**
*  @brief enum for SRS WOW Brightness
*/
typedef enum
{
    DRV_AUD_SRSWOW_BRIGHTNESS_LOW       = REG_SSD_WOW_BRIGHTNESS_VALUE_LOW,
    DRV_AUD_SRSWOW_BRIGHTNESS_MEDIUM    = REG_SSD_WOW_BRIGHTNESS_VALUE_MEDIUM,
    DRV_AUD_SRSWOW_BRIGHTNESS_HIGH      = REG_SSD_WOW_BRIGHTNESS_VALUE_HIGH,
} DRV_AudSRSWOWBrightness_t;

/**
*  @brief enum for SRS WOW Speaker Size
*/
typedef enum
{
    DRV_AUD_SRSWOW_SPEAKERSIZE_040HZ    = REG_SSD_WOW_SPKSIZE_VALUE_40HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_060HZ    = REG_SSD_WOW_SPKSIZE_VALUE_60HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_100HZ    = REG_SSD_WOW_SPKSIZE_VALUE_100HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_150HZ    = REG_SSD_WOW_SPKSIZE_VALUE_150HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_200HZ    = REG_SSD_WOW_SPKSIZE_VALUE_200HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_250HZ    = REG_SSD_WOW_SPKSIZE_VALUE_250HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_300HZ    = REG_SSD_WOW_SPKSIZE_VALUE_300HZ,
    DRV_AUD_SRSWOW_SPEAKERSIZE_400HZ    = REG_SSD_WOW_SPKSIZE_VALUE_400HZ,
} DRV_AudSRSWOWSpeakerSize_t;

/**
*  @brief enum for SRS WOW Bass Level
*/
typedef enum
{
    DRV_AUD_SRSWOW_BASSLEVEL_000_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_0,
    DRV_AUD_SRSWOW_BASSLEVEL_010_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_10,
    DRV_AUD_SRSWOW_BASSLEVEL_020_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_20,
    DRV_AUD_SRSWOW_BASSLEVEL_030_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_30,
    DRV_AUD_SRSWOW_BASSLEVEL_040_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_40,
    DRV_AUD_SRSWOW_BASSLEVEL_050_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_50,
    DRV_AUD_SRSWOW_BASSLEVEL_060_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_60,
    DRV_AUD_SRSWOW_BASSLEVEL_070_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_70,
    DRV_AUD_SRSWOW_BASSLEVEL_080_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_80,
    DRV_AUD_SRSWOW_BASSLEVEL_090_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_90,
    DRV_AUD_SRSWOW_BASSLEVEL_100_PERCENT    = REG_SSD_WOW_BASSLEVEL_VALUE_100,
} DRV_AudSRSWOWBassLevel_t;

/**
*  @brief enum for SRS WOW Stereo Width
*/
typedef enum
{
    DRV_AUD_SRSWOW_STEREOWIDTH_000_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_0,
    DRV_AUD_SRSWOW_STEREOWIDTH_010_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_10,
    DRV_AUD_SRSWOW_STEREOWIDTH_020_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_20,
    DRV_AUD_SRSWOW_STEREOWIDTH_030_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_30,
    DRV_AUD_SRSWOW_STEREOWIDTH_040_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_40,
    DRV_AUD_SRSWOW_STEREOWIDTH_050_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_50,
    DRV_AUD_SRSWOW_STEREOWIDTH_060_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_60,
    DRV_AUD_SRSWOW_STEREOWIDTH_070_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_70,
    DRV_AUD_SRSWOW_STEREOWIDTH_080_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_80,
    DRV_AUD_SRSWOW_STEREOWIDTH_090_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_90,
    DRV_AUD_SRSWOW_STEREOWIDTH_100_PERCENT  = REG_SSD_WOW_STEREOWIDTH_VALUE_100,
} DRV_AudSRSWOWStereoWidth_t;

/**
*  @brief enum for BBE Bass(at 100Hz) and Treble(at 10kHz) Boost
*/
typedef enum
{
    DRV_AUD_BBE_BOOST_00_000DB  = 0,
    DRV_AUD_BBE_BOOST_00_875DB,
    DRV_AUD_BBE_BOOST_01_750DB,
    DRV_AUD_BBE_BOOST_02_625DB,
    DRV_AUD_BBE_BOOST_03_500DB,
    DRV_AUD_BBE_BOOST_04_375DB,
    DRV_AUD_BBE_BOOST_05_250DB,
    DRV_AUD_BBE_BOOST_06_125DB,
    DRV_AUD_BBE_BOOST_07_000DB,
    DRV_AUD_BBE_BOOST_07_875DB,
    DRV_AUD_BBE_BOOST_08_750DB,
    DRV_AUD_BBE_BOOST_09_625DB,
    DRV_AUD_BBE_BOOST_10_500DB,
    DRV_AUD_BBE_BOOST_11_375DB,
    DRV_AUD_BBE_BOOST_12_250DB,
    DRV_AUD_BBE_BOOST_13_125DB,
} DRV_AudBBEBoost_t;

/**
*  @brief enum for Monitor Sorce
*/
typedef enum
{
    DRV_AUD_MONITOR_SOURCE_FM_AM_MPX_1FS                                    = REG_SSD_MON_SRC_VALUE_FM_AM_MPX_1_FS_INPUT,
    DRV_AUD_MONITOR_SOURCE_FM_AM_MPX_4FS                                    = REG_SSD_MON_SRC_VALUE_FM_AM_MPX_4_FS_INPUT,
    DRV_AUD_MONITOR_SOURCE_FM_AM_BTSC_EIAJ                                  = REG_SSD_MON_SRC_VALUE_FM_AM_BTSC_EIAJ_DC,
    DRV_AUD_MONITOR_SOURCE_FM_DEMATRIX                                      = REG_SSD_MON_SRC_VALUE_FM_DEMATRIX_OUTPUT,
    DRV_AUD_MONITOR_SOURCE_NICAM_BEFORE_SOFTMUTE                            = REG_SSD_MON_SRC_VALUE_NICAM_BEFORE_SOFTMUTE,
    DRV_AUD_MONITOR_SOURCE_MONO_BEFORE_SOFTMUTE                             = REG_SSD_MON_SRC_VALUE_MONO_BEFORE_SOFTMUTE,
    DRV_AUD_MONITOR_SOURCE_SAP_BEFORE_SOFTMUTE                              = REG_SSD_MON_SRC_VALUE_SAP_BEFORE_SOFTMUTE,
    DRV_AUD_MONITOR_SOURCE_ADC_AT_DIG_INPUT_CROSSBAR                        = REG_SSD_MON_SRC_VALUE_ADC_AT_DIG_INPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_NOISE_SILENCE_GENERATOR_AT_DIG_INPUT_CROSSBAR    = REG_SSD_MON_SRC_VALUE_NOISE_SILENCE_GENERATOR_AT_DIG_INPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_SRC1_AT_DIG_INPUT_CROSSBAR                       = REG_SSD_MON_SRC_VALUE_SRC1_AT_DIG_INPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_SRC2_AT_DIG_INPUT_CROSSBAR                       = REG_SSD_MON_SRC_VALUE_SRC2_AT_DIG_INPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_MAIN_AT_DIG_OUTPUT_CROSSBAR                      = REG_SSD_MON_SRC_VALUE_MAIN_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_SUBWOOFER_AT_DIG_OUTPUT_CROSSBAR                 = REG_SSD_MON_SRC_VALUE_SUBWOOFER_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_CENTER_SURROUND_AT_DIG_OUTPUT_CROSSBAR           = REG_SSD_MON_SRC_VALUE_CENTER_SURROUND_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_SURROUND_AUX1L_AT_DIG_OUTPUT_CROSSBAR            = REG_SSD_MON_SRC_VALUE_SURROUND_AUX1L_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_AUX1L_R_AT_DIG_OUTPUT_CROSSBAR                   = REG_SSD_MON_SRC_VALUE_AUX1L_R_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_AUX2L_R_AT_DIG_OUTPUT_CROSSBAR                   = REG_SSD_MON_SRC_VALUE_AUX2L_R_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_AUX3L_R_AT_DIG_OUTPUT_CROSSBAR                   = REG_SSD_MON_SRC_VALUE_AUX3L_R_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_MAIN_SUM_SILENCE_AT_DIG_OUTPUT_CROSSBAR          = REG_SSD_MON_SRC_VALUE_MAIN_SUM_SILENCE_AT_DIG_OUTPUT_CROSSBAR,
    DRV_AUD_MONITOR_SOURCE_MAIN_L_R_AFTER_BASS_MANAGEMENT                   = REG_SSD_MON_SRC_VALUE_MAIN_L_R_AFTER_BASS_MANAGEMENT,
    DRV_AUD_MONITOR_SOURCE_SUBWOOFER_CENTER_AFTER_BASS_MANAGEMENT           = REG_SSD_MON_SRC_VALUE_SUBWOOFER_CENTER_AFTER_BASS_MANAGEMENT,
    DRV_AUD_MONITOR_SOURCE_CENTER_SURROUND_AFTER_BASS_MANAGEMENT            = REG_SSD_MON_SRC_VALUE_CENTER_SURROUND_AFTER_BASS_MANAGEMENT,
} DRV_AudMonitorSource_t;

/**
*  @brief enum for Monitor mode
*/
typedef enum
{
    DRV_AUD_MONITOR_RANDOM_SAMPLE_MODE                  = REG_SSD_MON_DET_VALUE_RANDOM_SAMPLES,
    DRV_AUD_MONITOR_ABSOLUTE_VALUE_PEAK_DETECTION_MODE  = REG_SSD_MON_DET_VALUE_ABSOLUTE_VALUE_PEAK_DETECTION,
    DRV_AUD_MONITOR_QUASI_PEAK_DETECTION_MODE           = REG_SSD_MON_DET_VALUE_QUASI_PEAK_DETECTION,
    DRV_AUD_MONITOR_OFF_RESET_DETECTOR_MODE             = REG_SSD_MON_DET_VALUE_OFF_RESET_PEAK_DETECTOR,
} DRV_AudMonitorMode_t;

/**
*  @brief enum for Monitor Matrix
*/
typedef enum
{
    DRV_AUD_MONITOR_MATRIX_A                = REG_SSD_MON_MAT_VALUE_A,
    DRV_AUD_MONITOR_MATRIX_HALF_A_AND_B     = REG_SSD_MON_MAT_VALUE_A_B_2,
    DRV_AUD_MONITOR_MATRIX_B                = REG_SSD_MON_MAT_VALUE_B,
    DRV_AUD_MONITOR_MATRIX_HALF_A_MINUS_B   = REG_SSD_MON_MAT_VALUE_A_B_2_2_CH_SOURCES_ONLY,
} DRV_AudMonitorMatrix_t;

/**
*  @brief enum for Beeper Frequency
*/
typedef enum
{
    DRV_AUD_BEEPERFREQUENCY_00030HZ = 0,
    DRV_AUD_BEEPERFREQUENCY_00060HZ,
    DRV_AUD_BEEPERFREQUENCY_00090HZ,
    DRV_AUD_BEEPERFREQUENCY_00120HZ,
    DRV_AUD_BEEPERFREQUENCY_00150HZ,
    DRV_AUD_BEEPERFREQUENCY_00180HZ,
    DRV_AUD_BEEPERFREQUENCY_00250HZ,
    DRV_AUD_BEEPERFREQUENCY_00300HZ,
    DRV_AUD_BEEPERFREQUENCY_00200HZ,
    DRV_AUD_BEEPERFREQUENCY_00400HZ,
    DRV_AUD_BEEPERFREQUENCY_01000HZ,
    DRV_AUD_BEEPERFREQUENCY_02000HZ,
    DRV_AUD_BEEPERFREQUENCY_03000HZ,
    DRV_AUD_BEEPERFREQUENCY_05000HZ,
    DRV_AUD_BEEPERFREQUENCY_08000HZ,
    DRV_AUD_BEEPERFREQUENCY_12500HZ,
} DRV_AudBeeperFrequency_t;

/**
*  @brief enum for Beeper Mode
*/
typedef enum
{
    DRV_AUD_BEEPER_GRAPHIC_MODE     = 0,
    DRV_AUD_BEEPER_PARAMETRIC_MODE,
} DRV_AudBeeperMode_t;

/**
*  @brief enum for silence detection channel
*/
typedef enum
{
    DRV_AUD_SILENCE_DETECTION_CHANNEL_MAIN               = 0,
    DRV_AUD_SILENCE_DETECTION_CHANNEL_AUX1,
} DRV_AudSilenceDetectionChannel_t;

/**
*  @brief enum for silence detection threshold
*/
typedef enum
{
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_30_DBFS   = 0,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_33_DBFS   = 1,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_36_DBFS   = 2,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_45_DBFS   = 5,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_60_DBFS   = 10,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_75_DBFS   = 15,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_90_DBFS   = 20,
    DRV_AUD_SILENCE_DETECTION_THRESHOLD_MINUS_120_DBFS  = 30,
} DRV_AudSilenceDetectionThreshold_t;

/**
*  @brief enum for delay (in samples) of soft-mute after silence detected
*/
typedef enum
{
    DRV_AUD_SILENCE_DETECTION_DELAY_32_SAMPLES      = 0,
    DRV_AUD_SILENCE_DETECTION_DELAY_64_SAMPLES      = 1,
    DRV_AUD_SILENCE_DETECTION_DELAY_128_SAMPLES     = 2,
    DRV_AUD_SILENCE_DETECTION_DELAY_256_SAMPLES     = 3,
    DRV_AUD_SILENCE_DETECTION_DELAY_1024_SAMPLES    = 5,
    DRV_AUD_SILENCE_DETECTION_DELAY_8192_SAMPLES    = 8,
    DRV_AUD_SILENCE_DETECTION_DELAY_32768_SAMPLES   = 10,
} DRV_AudSilenceDetectionDelay_t;

/*******************************************************************************
* Structure
******************************************************************************/
typedef struct
{
    Boolean fEnVDS;
    Boolean fEnSRSTruSurroundPassiveMatrix;
    Boolean fEnSRS3D;
    Boolean fEnBBE;
    Boolean fEnSRSTruSurroundXT;
    Boolean fEnSRSWOW;
} DRV_AudFeatureVersion_t;

typedef struct
{
    UINT32 dLipSyncMemoryStarAddress;   //!memory star address for lip sync (dely line unit)
	UINT32 dLipSyncMemorySize;		    //!memory size for lip sync (dely line unit)
}DRV_AudInitialConfig_t;

typedef struct
{
    UINT32 reserved;    //!reserved parameter
}DRV_AudUnInitialConfig_t;

typedef struct
{
    union
    {
        UINT32 _INF_DEV_STA_REG;//SSD register address = 0x00004
        struct
        {
            UINT32 STDRES    :5;
            UINT32 GST       :1;
            UINT32 GDU       :1;
            UINT32 RESERVED0 :1;
            UINT32 ADU       :1;
            UINT32 AST       :1;
            UINT32 AAMUT     :1;
            UINT32 BPILOT    :1;
            UINT32 SAPDET    :1;
            UINT32 BAMUT     :1;
            UINT32 SAMUT     :1;
            UINT32 VDSP_C    :1;
            UINT32 NICST_C   :1;
            UINT32 NICDU_C   :1;
            UINT32 NAMUT     :1;
            UINT32 RSSF      :1;
            UINT32 INITSTAT  :1;
            UINT32 RESERVED1 :3;
            UINT32 RESERVED2 :8;
        } INF_DEV_STA_REG;
    };

    union
    {
        UINT32 _INF_NIC_STA_REG;//SSD register address = 0x00008
        struct
        {
            UINT32 ERR_OUT   :8;
            UINT32 CFC       :1;
            UINT32 CO_LOCKED :1;
            UINT32 NACB      :4;
            UINT32 VDSP      :1;
            UINT32 NICST     :1;
            UINT32 NICDU     :1;
            UINT32 RESERVED0 :7;
            UINT32 RESERVED1 :8;
        } INF_NIC_STA_REG;
    };

    union
    {
        UINT32 _INF_NIC_ADD_REG;//SSD register address = 0x0000c
        struct
        {
            UINT32 ADW       :11;
            UINT32 RESERVED0 :6;
            UINT32 RESERVED1 :7;
            UINT32 RESERVED2 :8;
        } INF_NIC_ADD_REG;
    };

    union
    {
        UINT32 _INF_LEV_MON_REG;//SSD register address = 0x00018
        struct
        {
            UINT32 MONLEVEL  :24;
            UINT32 RESERVED0 :8;
        } INF_LEV_MON_REG;
    };

    union
    {
        UINT32 _INF_MPX_LEVEL_REG;//SSD register address = 0x0001c
        struct
        {
            UINT32 HW_AST    :1;
            UINT32 HW_ADU    :1;
            UINT32 FI_AST    :1;
            UINT32 FI_ADU    :1;
            UINT32 RESERVED0 :2;
            UINT32 MPXPLEV   :18;
            UINT32 RESERVED1 :8;
        } INF_MPX_LEVEL_REG;
    };

    union
    {
        UINT32 _INF_NOISELEVEL_REG;//SSD register address = 0x00028
        struct
        {
            UINT32 NDETCH_STAT       :1;
            UINT32 NDETPB_STAT       :1;
            UINT32 NOISELEVEL        :22;
            UINT32 RESERVED0         :8;
        } INF_NOISELEVEL_REG;
    };

    union
    {
        UINT32 _INF_OVMADAPT_REG;//SSD register address = 0x0002c
        struct
        {
            UINT32 FILTBW_STAT       :2;
            UINT32 RESERVED0         :10;
            UINT32 OVM_SCALE_STAT    :12;
            UINT32 RESERVED1         :8;
        } INF_OVMADAPT_REG;
    };
} DRV_AudFrontEndReg_t;

/*******************************************************************************
* Variable
******************************************************************************/

/*******************************************************************************
* Marco
******************************************************************************/
#define DTV_DRV_AUDIO_DEBUG_MSG_ENABLE
#ifdef DTV_DRV_AUDIO_DEBUG_MSG_ENABLE//(DTV_DRV_AUDIO_DEBUG_MSG_ENABLE)
#define DRV_AUDIO_DBG(fmt, arg...)          diag_printf("\n@Drv_Audio Debug:\n%s %s %d:"fmt,\
                                                __FILE__, __FUNCTION__, __LINE__, ##arg)
#else
#define DRV_AUDIO_DBG(fmt, arg...)
#endif

#define DTV_DRV_AUDIO_WARNING_MSG_ENABLE
#ifdef DTV_DRV_AUDIO_WARNING_MSG_ENABLE//(DTV_DRV_AUDIO_WARNING_MSG_ENABLE)
#define DTV_DRV_AUDIO_WAR(fmt, arg...)           diag_printf("\n@Drv_Audio Warning:\n%s %s %d:"fmt,\
                                                __FILE__, __FUNCTION__, __LINE__, ##arg)
#else
#define DRV_AUDIO_WAR(fmt, arg...)
#endif

#define DTV_DRV_AUDIO_ERROR_MSG_ENABLE
#ifdef DTV_DRV_AUDIO_ERROR_MSG_ENABLE//(DTV_DRV_AUDIO_ERROR_MSG_ENABLE)
#define DTV_DRV_AUDIO_ERR(fmt, arg...)           diag_printf("\n@Drv_Audio Error:\n%s %s %d:"fmt,\
                                                __FILE__, __FUNCTION__, __LINE__, ##arg)
#else
#define DRV_AUDIO_ERR(fmt, arg...)
#endif

/*******************************************************************************
* Program
******************************************************************************/
#if 1
/******************************************************************************/
/**
* @brief    This function enable SSD ROM chip
* @param    fEn : enable SSD rom access if fEn = DTV_TRUE
*                 disable SSD for power saving if fEn = DTV_FALSE
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudEnableSSDROMReg(Boolean fEn);


/******************************************************************************/
/**
* @brief    This function read data from SSD with assigned address
* @param    dSSDAddr : SSD DTL Address
* @param    dSSDDataBitMask : SSD data mask
* @param    bSSDDataBitIndex : lowest bit index of SSD data (0..31)
* @param    pRetData : return SSD data
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudReadSSDReg(UINT32 dSSDAddr,
                    UINT32 dSSDDataBitMask,
                    UINT8 bSSDDataBitIndex,
                    UINT32 *pRetData);

/******************************************************************************/
/**
* @brief    This function read data from SSD via DTL interface
* @param    dDTLAddr : SSD DTL Address
* @param    pdRetDTLData : SSD data read from assigned address
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_SSD_DTL_Read(UINT32 dDTLAddr, UINT32 *pdRetDTLData);

/******************************************************************************/
/**
* @brief    This function write data from SSD via DTL interface
* @param    dDTLAddr : SSD DTL Address
* @param    dDTLData : SSD write data with assigned address
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_SSD_DTL_Write(UINT32 dDTLAddr, UINT32 dDTLData);

/******************************************************************************/
/**
* @brief    Set power control configuration
* @param    ePowerControl : power control parameter
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetPowerControl(DRV_AudPowerControl_t ePowerControl);

/******************************************************************************/
/**
* @brief    Audio driver initial function
* @param    pInitialParam : initial parameters for audio driver initial
*		        pInitialParam->LipSyncMemoryStarAddress : memory star address for lip sync
*		        pInitialParam->LipSyncMemorySize : memory size for lip sync
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudInit(void);

/******************************************************************************/
/**
* @brief    Audio driver un-initial function
* @param    pUnInitialParam : Un-initial parameters for audio driver initial
*		        pUnInitialParam->reserved : reserved parameter
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudUninit(DRV_AudUnInitialConfig_t *pUnInitialParam);

/******************************************************************************/
/**
* @brief    Get feature version
* @param    pRetFeatureVersion : feature verion data
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetFeatureVersion(DRV_AudFeatureVersion_t *pRetFeatureVersion);

/******************************************************************************/
/**
* @brief    Set Overmodulation configuration
* @param    fEnAdapter : DTV_TRUE : enable FM overmodulation adaptation
*                        DTV_FALSE : disable FM overmodulation adaptation
* @param    bFilterBanndWidth : active if bFilterBanndWidth = DTV_TRUE
*                               0 = narrow
*                               2 = medium
*								3 = wide
*                               1 = extra wide (only ch. 1 active)
* @param    bLevelThershold : active if bFilterBanndWidth = DTV_TRUE
*                               0 = +3 dB = -12 dBFS
*                               1 = +6 dB = - 9 dBFS
*                               2 = +9 dB = -6 dBFS
*                               3 = +12 dB= -3 dBFS
* @param    bAttenuation : active if bFilterBanndWidth = DTV_FALSE
*                               0(0 dB) ~ 31(31 dB) attenuation of analog standard
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetOverModulationAdapterConfig(Boolean fEnAdapter,
															UINT8 bFilterBanndWidth,
															UINT8 bLevelThershold,
															UINT8 bAttenuation);

/******************************************************************************/
/**
* @brief    Set magnitude detect configuration
* @param    bCarrier1_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),threshold for detection of first sound carrier (SC1) during ASD first step, relative to -30 dBFS. -16 prevents ASD "failure" to produce output regardless of carrier level.
* @param    bMPX_threshold_low : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),lower threshold for MPX pilot detection (BTSC, FM RADIO) in dB below nominal level
* @param    bMPX_threshold_up : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),upper threshold for MPX pilot detection (BTSC, FM RADIO) in dB below nominal level
* @param    bSAP_threshold_low : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),lower threshold for SAP carrier detection in dB below nominal level
* @param    bSAP_threshold_up : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),upper threshold for SAP carrier detection in dB below nominal level
* @param    fEnSub_carrier_detect : DTV_TRUE : enable EIAJ sub carrier detect
*                                   DTV_FALSE : disable EIAJ sub carrier detect
* @param    bEIAJ_sub_carrier_threshold_low : 0(0 dB) ~ 15(+15),(1 step is 1 dB),lower threshold for EIAJ SUB carrier detection in dB below nominal level
* @param    bEIAJ_sub_carrier_threshold_up : 0(0 dB) ~ 15(+15),(1 step is 1 dB),upper threshold for EIAJ SUB carrier detection in dB below nominal level
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMagnitudeDetectConfig(INT8 bCarrier1_threshold,
                                                        UINT8 bMPX_threshold_low,
                                                        UINT8 bMPX_threshold_up,
                                                        UINT8 bSAP_threshold_low,
                                                        UINT8 bSAP_threshold_up,
                                                        Boolean fEnSub_carrier_detect,
                                                        UINT8 bEIAJ_sub_carrier_threshold_low,
                                                        UINT8 bEIAJ_sub_carrier_threshold_up);

/******************************************************************************/
/**
* @brief    Set SAP auto mute configuration
* @param    bSAP_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of SAP (-16 means automute off)
* @param    bSAP_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of SAP
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSAPAutoMuteConfig(INT8 bSAP_nmute_threshold,
                                                    UINT8 bSAP_nmute_hysteresis);

/******************************************************************************/
/**
* @brief    Set FM/A2 sound carrier 2 auto mute configuration
* @param    bFM_A2_sc2_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of SC2 in FM A2 standards     (-16 means automute off)
* @param    bFM_A2_sc2_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of SC2 in FM A2 standards
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetFMA2Carrier2AutoMuteConfig(INT8 bFM_A2_sc2_nmute_threshold,
                                                            UINT8 bFM_A2_sc2_nmute_hysteresis);

/******************************************************************************/
/**
* @brief    Set BTSC auto mute configuration
* @param    bBTSC_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of BTSC stereo carrier (-16 means automute off)
* @param    bBTSC_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of BTSC stereo
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetBTSCAutoMuteConfig(INT8 bBTSC_nmute_threshold,
                                                    UINT8 bBTSC_nmute_hysteresis);

/******************************************************************************/
/**
* @brief    Set FM radio auto mute configuration
* @param    bFM_radio_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of FM RADIO stereo carrier (-16 means automute off)
* @param    bFM_radio_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of FM RADIO stereo
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetFMRadioAutoMuteConfig(INT8 bFM_radio_nmute_threshold,
                                                        UINT8 bFM_radio_nmute_hysteresis);

/******************************************************************************/
/**
* @brief    Set EIAJ sub carrier auto mute configuration
* @param    bSub_carrier_nmute_threshold : -16(-16 dB) ~ 15(+15),(1 step is 1 dB),noise threshold for automute of EIAJ FM subcarrier (-16 means automute off)
* @param    bSub_carrier_nmute_hysteresis : 0(0 dB) ~ 15(+15),(1 step is 1 dB),hysteresis size [dB] for automute of EIAJ FM subcarrier
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetEIAJSubCarrierAutoMuteConfig(INT8 bSub_carrier_nmute_threshold,
                                                            UINT8 bSub_carrier_nmute_hysteresis);

/******************************************************************************/
/**
* @brief    Set NICAM configuration
* @param    fEnOnly_related : DTV_TRUE : enable to reproduce only related NICAM on DEC output (DDEP only)
*                             DTV_FALSE : disable to reproduce only related NICAM on DEC output (DDEP only)
* @param    fEnDeemphasis : DTV_TRUE : enable NICAM deemphasis (J17) (all modes)
*                           DTV_FALSE : disable NICAM deemphasis (J17) (all modes)
* @param    fEnAuto_mute : DTV_TRUE : enable NICAM auto mute function depending on bit error rate (DDEP only)
*                          DTV_FALSE : disable NICAM auto mute function depending on bit error rate (DDEP only)
* @param    bLower_error_limit : 0 ~ 255,NICAM lower error limit (DDEP only)
* @param    bUpper_error_limit : 0 ~ 255,NICAM upper error limit (DDEP only)
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetNICAMConfig(Boolean fEnOnly_related,
                                            Boolean fEnDeemphasis,
                                            Boolean fEnAuto_mute,
                                            UINT8 bLower_error_limit,
                                            UINT8 bUpper_error_limit);

/******************************************************************************/
/**
* @brief    Set DEMDEC standard detection Action
* @param    eAction : star/release DEMDEC stardard detect
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetDetectStandard(DRV_AudDEMDECResetAction_t eAction);

/******************************************************************************/
/**
* @brief    Get detected SIF Standard from DEMDEC
* @param    pRetAudioStandard : report IF sound standard
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetStandard(DRV_AudStandard_t *pRetAudioStandard);

/******************************************************************************/
/**
* @brief    Get if SAP available
* @param    pfRetSAP : report if SAP detected
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetIfSAP(Boolean *pfRetSAP);

/******************************************************************************/
/**
* @brief    Get If dual(bilingual) available
* @param    pfRetDual : report if (bilingual) detected
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
 ******************************************************************************/
DRV_Status_t DRV_AudGetIfDual(Boolean *pfRetDual);

/******************************************************************************/
/**
* @brief    Get if stereo available
* @param    pfRetStereo : report if stereo detected
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetIfStereo(Boolean *pfRetStereo);

/******************************************************************************/
/**
* @brief    Get if NICAM available
* @param    pfRetNicam : report if NICAM detected
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetIfNICAM(Boolean *pfRetNicam);

/******************************************************************************/
/**
* @brief    Get front end status from registers
* @param    pfRetFrontEndReg : report if front end register values
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetFrontEndRegInfo(DRV_AudFrontEndReg_t *pfRetFrontEndReg);

/******************************************************************************/
/**
* @brief    Set BTSC DBX mode
* @param    eMode : select DBX NR mode
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetBTSCDBXMode(DRV_AudBTSCDBXMode_t eMode);

/******************************************************************************/
/**
* @brief    Set standard detect mask for DEMDEC ADS(Auto Standard Detect) mode
* @param    eAutoStandardGroup : specify standard recognization mask
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetAutoStandardSelection(DRV_AudAutoStandardGroup_t eAutoStandardGroup);

/******************************************************************************/
/**
* @brief    Set standard detect mask for DEMDEC SSS(Static Standard Selection) mode
* @param    eStaticStandard :
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetStaticStandardSelection(DRV_AudStaticStandardSelection_t eStaticStandard);

/******************************************************************************/
/**
* @brief    Set NICAM QPSK rotate angle, only for I NICAM standard
* @param    eRotateAngle : rotate angle for I NICAM
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetINICAMRotateAngle(DRV_AudNICAMRotateAngle_t eRotateAngle);

/******************************************************************************/
/**
* @brief    Set adjust level configuration
* @param    bDECAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param    bMonoAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param    bNICAMAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param    bSAPAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param    bADCAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param    bDigitalAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetPathAdjustLevel(INT8 bDECAdjustLevel,
                                                INT8 bMonoAdjustLevel,
                                                INT8 bNICAMAdjustLevel,
                                                INT8 bSAPAdjustLevel,
                                                INT8 bADCAdjustLevel,
                                                INT8 bDigitalAdjustLevel);

/******************************************************************************/
/**
* @brief    Set digital divider for digital audio input
* @param    eDigitalDividerMode : select sample rate divider
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetDigitalDivider(DRV_AudDigitalDivider_t eDigitalDividerMode);

/******************************************************************************/
/**
* @brief    Set digital input de-emphasis
* @param    eDigitalDeemphasisMode : config de-emphasis mode
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetDigitalInputDeemphasis(DRV_AudDigitalDeemphasis_t eDigitalDeemphasisMode);

/******************************************************************************/
/**
* @brief    Set digital matrix configuration
* @param    eProcessPath : specify process path
* @param    eDigitalMatrix : specify Digital Matrix
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetDigitalMatrix(DRV_AudProcessPath_t eProcessPath,
                                 DRV_AudDigitalMatrix_t eDigitalMatrix);

/******************************************************************************/
/**
* @brief    Set SIF input selection
* @param    eIFSource : select SIF input source
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetIFInput(DRV_AudIFInput_t eIFSource);


/******************************************************************************//**
* @brief    Set line-in ADC input selection
* @param    eADCSource : line-in ADC Source for analog input
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetADCInput(DRV_AudADCInput_t eADCSource);

/******************************************************************************/
/**
* @brief    Set digital input selection
* @param    eDigitalSource : digital input selection
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetDigitalInput(DRV_AudDigitalInput_t eDigitalSource);

/******************************************************************************/
/**
* @brief    Specify SRC(sample rate converter) with source selection
* @param    eSRCPath : SRC path selection
* @param    eSRCSource : SRC source selection
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSRCPath(DRV_AudSRCPath_t eSRCPath,
                           DRV_AudSRCSource_t eSRCSource);

/******************************************************************************/
/**
* @brief    Set source for sound process path
* @param    eMainAUXPath : process path
* @param    eSource : source selection for process path
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainAUXPath(DRV_AudProcessPath_t eMainAUXPath,
                               DRV_AudMainAUXSource_t eSource);

/******************************************************************************/
/**
* @brief    Set configuration for center and surround process path
* @param    eCenterSurroundPath : assign center/surround process path
* @param    eSource :  assign source for center/surround process path
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetCenterSurroundPath(DRV_AudProcessPath_t eCenterSurroundPath,
                               DRV_AudCenterSurroundSource_t eSource);

/******************************************************************************/
/**
* @brief    Enable/disable auto-sleep function of DAC
* @param    fEn : DTV_TRUE : enable DAC auto sleep
*                 DTV_FALSE : disable DAC auto sleep
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetDACAutoSleep(Boolean fEn);

/******************************************************************************/
/**
* @brief    Initial I2S output cross bar
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudI2SOutputCrossbarInit(void);

#ifdef NEW_OUTPUT_CONFIG_METHOD
/******************************************************************************/
/**
* @brief    Set I2S output format configuration
* @param    fEnBitClockInvert : DTV_TRUE : enable bit clock inverse
*                           	DTV_FALSE : disable bit clock inverse
* @param    eOutPut : select SSD output channel to change I2S format,
*                        DTV_DRV_AUD_SSD_OUTPUT_SD0 and DTV_DRV_AUD_SSD_OUTPUT_SD1 will be the same format
* @param    eFormat : I2S format selection
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
* @note     SSD SD0 will output via DAC0 or I2S SD0
* @note     SSD SD1 will output via DAC1 or I2S SD1
* @note     SSD SD2 will output via DAC2 or I2S SD2
* @note     DTV_DRV_AUD_OUTPUT_I2S_SD0 and DTV_DRV_AUD_OUTPUT_I2S_SD1 will be the same format
******************************************************************************/
DRV_Status_t DRV_AudSetI2SOutputFormat(Boolean fEnBitClockInvert,
												DRV_AudOutputPath_t eOutPut,
												DRV_AudI2SOutputFormat_t eFormat);

/******************************************************************************/
/**
* @brief    Config audio output corss bar
* @param    eSource : specify which source input to crossbar
* @param    eDestination : specify channel to output audio data
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetOutputCrossbasrConfig(DRV_AudOutputCrossbarSource_t eSource,
                                                        DRV_AudOutputPath_t eDestination);

#if 1
/******************************************************************************/
/**
* @brief    Set output path configuration
* @param    eCrossbarSource : SSD ouput port selection
* @param    eOutputLeftChannelSource : source for output left channel
* @param    eOutputRightChannelSource : source for output right channel
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetOutputConfig(DRV_AudOutputCrossbarSource_t eCrossbarSource,
                                                DRV_AudSSDOutputSource_t eOutputLeftChannelSource,
                                                DRV_AudSSDOutputSource_t eOutputRightChannelSource);
#else
/******************************************************************************/
/**
* @brief    Set output path configuration
* @param    eOutputChannel : ouput channel selection
* @param    eOutputLeftChannelSource : source for output left channel
* @param    eOutputRightChannelSource : source for output right channel
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
* @note     SSD SD0 will output via DAC0 or I2S SD0
* @note     SSD SD1 will output via DAC1 or I2S SD1
* @note     SSD SD2 will output via DAC2 or I2S SD2
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetOutputConfig(DTV_DRV_AudOutputPath_t eOutputChannel,
                                                DTV_DRV_AudSSDOutputSource_t eOutputLeftChannelSource,
                                                DTV_DRV_AudSSDOutputSource_t eOutputRightChannelSource);
#endif

#else
/******************************************************************************/
/**
* @brief    Set I2S output format configuration
* @param    fEnBitClockInvert : DTV_TRUE : enable bit clock inverse
*                           	DTV_FALSE : disable bit clock inverse
* @param    eOutPut : select SSD output channel to change I2S format,
*                        DTV_DRV_AUD_SSD_OUTPUT_SD0 and DTV_DRV_AUD_SSD_OUTPUT_SD1 will be the same format
* @param    eFormat : I2S format selection
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
* @note     SSD SD0 will output via DAC0 or I2S SD0
* @note     SSD SD1 will output via DAC1 or I2S SD1
* @note     SSD SD2 will output via DAC2 or I2S SD2
* @note     DTV_DRV_AUD_OUTPUT_I2S_SD0 and DTV_DRV_AUD_OUTPUT_I2S_SD1 will be the same format
******************************************************************************/
DRV_Status_t DRV_AudSetI2SOutputFormat(Boolean fEnBitClockInvert,
												DRV_AudSSDOutputPath_t eOutPut,
												DRV_AudI2SOutputFormat_t eFormat);

/******************************************************************************/
/**
* @brief    Config audio output corss bar
* @param    eSource : specify which source input to crossbar
* @param    eDestination : specify channel to output audio data
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetOutputCrossbasrConfig(DRV_AudOutputCrossbarSource_t eSource,
															DRV_AudOutputCrossbarDestination_t eDestination);

/******************************************************************************/
/**
* @brief    Set output path configuration
* @param    eOutputChannel : ouput channel selection
* @param    eOutputLeftChannelSource : source for output left channel
* @param    eOutputRightChannelSource : source for output right channel
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetOutputPath(DRV_AudSSDOutputPath_t eOutputChannel,
                                            DRV_AudSSDOutputSource_t eOutputLeftChannelSource,
                                            DRV_AudSSDOutputSource_t eOutputRightChannelSource);
#endif

/******************************************************************************/
/**
* @brief    Enable/disable SSD SPDIF bypass
* @param    fEn : DTV_TRUE : enable bypass SPDIF,
*                 DTV_FALSE : disable bypass SPDIF
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetSPDIFPathBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief    Get if SSD bypass SPDIF input
* @param    fRetEn : DTV_TRUE : SPDIF bypass is enable,
*                    DTV_FALSE : SPDIF bypass is disable,
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetIfSPDIFPathBypass(Boolean* fRetEn);

/******************************************************************************/
/**
* @brief    Enable/disable SSD I2S bypass
* @param    fEn : DTV_TRUE : enable bypass I2S,
*                 DTV_FALSE : disable bypass I2S
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetI2SPathBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief    Set main path mixer configuration
* @param    eMainPathMixer : main path mixer selection
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetMainPathMixer(DRV_AudMainPathMixer_t eMainPathMixer);

/******************************************************************************/
/**
* @brief    Enable/disable DEMDEC mute
* @param    fEn : DTV_TRUE : Mute On
*                 DTV_FALSE : Mute Off
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetDEMDECMute(Boolean fEn);

/******************************************************************************/
/**
* @brief    Get if DEMDEC output mute
* @param    pfRetMute : DTV_TRUE : Mute On
*                       DTV_FALSE : Mute Off
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetDEMDECMute(Boolean *pfRetMute);

/******************************************************************************/
/**
* @brief    Mute assigned process path
* @param    eMutePath :  specify process path for mute control
* @param    fEn : DTV_TRUE : mute selected path
*                 DTV_FALSE : unmute selected path
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMutePath(DRV_AudMutePath_t eMutePath,
                                        Boolean fEn);

/******************************************************************************/
/**
* @brief    Set Master Volume
* @param    wMasterVolume : -672(mute) ~ 192 (+192 dB),(1 step is 0.125 dB), controls MAIN, SW, C and S in 1/8dB steps
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMasterVolume(INT16 wMasterVolume);

/******************************************************************************/
/**
* @brief    Get master volume value
* @param    pwRetMasterVolume : return master volume value
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMasterVolume(INT16 *pwRetMasterVolume);

/******************************************************************************/
/**
* @brief    Set main volume values
* @param    bLeftMainVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param    bRightMainVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainVolume(INT8 bLeftMainVolume,INT8 bRightMainVolume);

/******************************************************************************/
/**
* @brief    Get main volume values
* @param    pbRetLeftMainVolume : return main left channel volume value
* @param    pbRetRightMainVolume : return main right channel volume value
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMainVolume(INT8 *pbRetLeftMainVolume,INT8 *pbRetRightMainVolume);

/******************************************************************************/
/**
* @brief    Set subwoofer path volume
* @param    bSubwooferVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSubwooferVolume(INT8 bSubwooferVolume);

/******************************************************************************/
/**
* @brief    Set center path volume
* @param    bCenterVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetCenterVolume(INT8 bCenterVolume);

/******************************************************************************/
/**
* @brief    Set surround path volume
* @param    bSurroundVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSurroundVolume(INT8 bSurroundVolume);

/******************************************************************************/
/**
* @brief    Set AUX1 path volume
* @param    bLeftAUX1Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param    bRightAUX1Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetAUX1Volume(INT8 bLeftAUX1Volume,INT8 bRightAUX1Volume);

/******************************************************************************/
/**
* @brief    Set AUX2 path volume
* @param    bLeftAUX2Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param    bRightAUX2Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetAUX2Volume(INT8 bLeftAUX2Volume,INT8 bRightAUX2Volume);

/******************************************************************************/
/**
* @brief    Set AUX3 path volume
* @param    bLeftAUX3Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param    bRightAUX3Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetAUX3Volume(INT8 bLeftAUX3Volume,INT8 bRightAUX3Volume);

/******************************************************************************/
/**
* @brief    Set main bass
* @param    bMainBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainBass(INT8 bMainBass);

/******************************************************************************/
/**
* @brief    Get main bass value
* @param    pbRetMainBass : return main bass value
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMainBass(INT8 *pbRetMainBass);

/******************************************************************************/
/**
* @brief    Set center bass
* @param    bCenterBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetCenterBass(INT8 bCenterBass);

/******************************************************************************/
/**
* @brief    Get center bass value
* @param    pbRetCenterBass : return center bass value
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetCenterBass(INT8 *pbRetCenterBass);

/******************************************************************************/
/**
* @brief    Set surround bass
* @param    bSurroundBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSurroundBass(INT8 bSurroundBass);

/******************************************************************************/
/**
* @brief    Get surround bass value
* @param    pbRetSurroundBass : return surround bass value
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetSurroundBass(INT8 *pbRetSurroundBass);

/******************************************************************************/
/**
* @brief    Set main treble
* @param    bMainTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainTreble(INT8 bMainTreble);

/******************************************************************************/
/**
* @brief    Get main treble values
* @param    pbRetMainTreble : return main treble vaule
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMainTreble(INT8 *pbRetMainTreble);

/******************************************************************************/
/**
* @brief    Set center treble
* @param    bCenterTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetCenterTreble(INT8 bCenterTreble);

/******************************************************************************/
/**
* @brief    Get center treble values
* @param    pbRetCenterTreble : return center treble vaule
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetCenterTreble(INT8 *pbRetCenterTreble);

/******************************************************************************/
/**
* @brief    Set surround treble
* @param    bSurroundTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSurroundTreble(INT8 bSurroundTreble);

/******************************************************************************/
/**
* @brief    Get surround treble values
* @param    pbRetSurroundTreble : return Surround treble vaule
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetSurroundTreble(INT8 *pbRetSurroundTreble);


/******************************************************************************/
/**
* @brief    Set main equalizer configuration
* @param    bBand1_0100Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand2_000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand3_1000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand4_3000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand5_8000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainEqualizer(INT8 bBand1_0100Hz,
                                                INT8 bBand2_000Hz,
                                                INT8 bBand3_1000Hz,
                                                INT8 bBand4_3000Hz,
                                                INT8 bBand5_8000Hz);

/******************************************************************************/
/**
* @brief    Get main equalizer configuration
* @param    pbRetBand1_0100Hz : return value of 0100 Hz main equalizer band
* @param    pbRetBand2_0300Hz : return value of 0300 Hz main equalizer band
* @param    pbRetBand3_1000Hz : return value of 1000 Hz main equalizer band
* @param    pbRetBand4_3000Hz : return value of 3000 Hz main equalizer band
* @param    pbRetBand5_8000Hz : return value of 8000 Hz main equalizer band
* @return   DTV_DRV_SUCCESS if successful
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMainEqualizer(INT8 *pbRetBand1_0100Hz,
                                                INT8 *pbRetBand2_0300Hz,
                                                INT8 *pbRetBand3_1000Hz,
                                                INT8 *pbRetBand4_3000Hz,
                                                INT8 *pbRetBand5_8000Hz);

/******************************************************************************/
/**
* @brief    Set center equalizer configuration
* @param    bBand1_0100Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand2_0300Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand3_1000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand4_3000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param    bBand5_8000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetCenterEqualizer(INT8 bBand1_0100Hz,
                                                INT8 bBand2_0300Hz,
                                                INT8 bBand3_1000Hz,
                                                INT8 bBand4_3000Hz,
                                                INT8 bBand5_8000Hz);

/******************************************************************************/
/**
* @brief    Get center equalizer configuration
* @param    pbRetBand1_0100Hz : return value of 0100 Hz main equalizer band
* @param    pbRetBand2_0300Hz : return value of 0300 Hz main equalizer band
* @param    pbRetBand3_1000Hz : return value of 1000 Hz main equalizer band
* @param    pbRetBand4_3000Hz : return value of 3000 Hz main equalizer band
* @param    pbRetBand5_8000Hz : return value of 8000 Hz main equalizer band
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetCenterEqualizer(INT8 *pbRetBand1_0100Hz,
                                                INT8 *pbRetBand2_0300Hz,
                                                INT8 *pbRetBand3_1000Hz,
                                                INT8 *pbRetBand4_3000Hz,
                                                INT8 *pbRetBand5_8000Hz);

/******************************************************************************/
/**
* @brief    Enable/disable main and center equalizer bypass
* @param    fEn : Enable/Disable main and center equalizer bypass
* @return   DTV_DRV_SUCCESS if successful
******************************************************************************/
DRV_Status_t DRV_AudSetMainCenterEQBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief    Get if main and center equalizer bypass
* @param    pfRetEn : return if main and center equalizer bypass
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMainCenterEQBypass(Boolean *pfRetEn);

/******************************************************************************/
/**
* @brief    Set sound effect mode
* @param    eEffectMode : specify sound effect mode
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetEffectMode(DRV_AudEffectMode_t eEffectMode);

/******************************************************************************/
/**
* @brief    Set spatial effect
* @param    eSpatialEffect : specify spatial sound effect
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSpatialEffect(DRV_AudSpatialEffect_t eSpatialEffect);

/******************************************************************************/
/**
* @brief    Set spatializer selector
* @param    eSpatializerSelect : specify 3D sound/WOW sound type
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSRSSpatialSelector(DRV_AudSRSSpatializer_t eSpatializerSelect);

/******************************************************************************/
/**
* @brief    Set bass feature control
* @param    eBassFeature : select bass feature control type
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetBassFeatureControl(DRV_AudBassFeatureControl_t eBassFeature);

/******************************************************************************/
/**
* @brief    Set subwoofer mode
* @param    eSubwooferMode : subwoofer mode selection
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSubwooferMode(DRV_AudSubwooferMode_t eSubwooferMode);

/******************************************************************************/
/**
* @brief    Set AVL(Auto Volume Levelling) configuration
* @param    eMode : AVL mode control
* @param    bReference_level : 0 (-6 dBFS)~ 15(-36 dBFS),AVL reference level
*                              2 = high threshold | (-10 dBFS), small reduction ("daytime mode")
*                              7 = medium threshold | (-20 dBFS), medium reduction ("evening mode")
*                              12 = low threshold | (-30 dBFS), strong reduction ("night mode")
* @param    fEnWeightFilter : enable/disable weight filter
* @param    fEnPeakModeWithClipManagement : enable/disable peak mode with clip management
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetAVLConfig(DRV_AudAVLMode_t eMode,
                                            INT8 bReference_level,
                                            Boolean fEnWeightFilter,
                                            Boolean fEnPeakModeWithClipManagement);

/******************************************************************************/
/**
* @brief    Set main loudness configuration
* @param    fEnMainLoudness : DTV_TRUE : enable mainloudness process
*                             DTV_FALSE : disable mainloudness process
* @param    fEnExtraBass : DTV_TRUE : filter character is 1000 Hz,
*						   DTV_FALSE : filter character is 500 Hz
* @param    eNoneAttackVolumeLevel : main loudness none attack volume level
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMainLoudnessConfig(Boolean fEnMainLoudness,
                                                    Boolean fEnExtraBass,
                                                    DRV_AudMainLoudnessVolumeLevel_t eNoneAttackVolumeLevel);

/******************************************************************************/
/**
* @brief    Set DLU(Delay Line Unit) configuration
* @param    fEn : DTV_TRUE : enable delay line unit process
*                 DTV_FALSE : disable delay line unit process
* @param    bDelay : 0 ~ 63(1 step is 4 ms)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetDLUConfig(Boolean fEn,UINT8 bDelay);

/******************************************************************************/
/**
* @brief    Set DLU source selection
* @param    fEn : DTV_TRUE : enable AUX1 ~ delay line unit process
*                 DTV_FALSE : disable delay line unit process
* @param    eSource : source selection for DLU
* @return   DTV_DRV_SUCCESS if successful
* @note     This funciton is used to config DLU source for process path except main process path
******************************************************************************/
DRV_Status_t DRV_AudSetDLUSource(Boolean fEn,DRV_AudDLUSource_t eSource);

/******************************************************************************/
/**
* @brief    Set clip management mode
* @param    eClipManagementMode
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetClipManagementMode(DRV_AudClipManagementMode_t eClipManagementMode);

/******************************************************************************/
/**
* @brief    Set clip management configuration at DVM(Dynamic Volume Mode)
* @param    ePeakDetectSelection : clip management peakdetection selection
* @param    bRelease_range_upper_limit : 0 ~ 3,dynamic volume mode release range upper limit (clip management)
*                                        0 = -3.5 dBFS
*                                        1 = -6 dBFS
*                                        2 = -9 dBFS
*                                        3 = -12 dBFS
* @param    bRelease_range_lower_limit : 0 ~ 3,dynamic volume mode release range lower limit (clip management)
*                                        0 = -40 dBFS
*                                        1 = -50 dBFS
*                                        2 = -60 dBFS
*                                        3 = -inf
* @param    bAttack_speed : 0 ~ 1,dynamic volume mode attack speed
*                           0 = 4.8 dB/s
*                           1 = 9.6 dB/s
* @param    bRelease_speed : 0 ~ 3,dynamic volume mode release speed
*                            0 = 0.06 dB/s
*                            1 = 0.12 dB/s
*                            2 = 0.24 dB/s
*                            3 = 0.48 dB/s
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetClipManagementDVMConfig(DRV_AudDVMPeakDetectionSelection_t ePeakDetectSelection,
                                                        UINT8 bRelease_range_upper_limit,
                                                        UINT8 bRelease_range_lower_limit,
                                                        UINT8 bAttack_speed,
                                                        UINT8 bRelease_speed);

/******************************************************************************/
/**
* @brief    Set bass management configuration
* @param    eMode : bass management mode
* @param    eFilterCharacteristic : 0 ~ 15,bass management filtercharacteristics (50 - 400hz corner frequency)
* @param    fEnSubwooferFilter : DTV_TRUE : enable bass management subwoofer filter control
*                                DTV_FALSE : disable bass management subwoofer filter control
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetBassManagementConfig(DRV_AudBassManagementMode_t eMode,
                                                    DRV_AudBassManagementFilterCharacteristic_t eFilterCharacteristic,
                                                    Boolean fEnSubwooferFilter);

/******************************************************************************/
/**
* @brief    Set VDSII configuration
* @param    eEffectLevel : VDSII Effect Level: 0..100% (5 steps)
* @param    eBalanceControl : VDSII Balance Control
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetVDSIIConfig(DRV_AudVDSIIEffectLevel_t eEffectLevel,
                                            DRV_AudVDSIIBalanceControl_t eBalanceControl);

/******************************************************************************/
/**
* @brief    Set SRS TruSurround XT configuration
* @param    eMode : TSXT K Mode selection
* @param    fEnDialogClarity : DTV_TRUE : enable dialog clarity function control
*                              DTV_FALSE : disable dialog clarity function control
* @param    fEnTruBass : DTV_TRUE : enable TruBass function control
*                        DTV_FALSE : disable TruBass function control
* @param    fEnHeadphoneControl : DTV_TRUE : enable headphone control
*                                 DTV_FALSE : disable headphone control
* @param    fEnCenterOutputModeControl : DTV_TRUE : enable center output mode control
*                                        DTV_FALSE : disable center output mode control
* @param    eSpeakerSize : 0 ~ 7,speaker size selection
* @param    eTruBassGain : 0 ~ 15,trubass gain control
* @param    eDialogClarityGain : 0 ~ 15,dialog clarity gain control
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSRSTruSurroundXTConfig(DRV_AudSRSTrusurroundXT_K_Mode_t eMode,
                                                        Boolean fEnDialogClarity,
                                                        Boolean fEnTruBass,
                                                        Boolean fEnHeadphoneControl,
                                                        Boolean fEnCenterOutputModeControl,
                                                        DRV_AudSRSTrusurroundXT_SpeakerSize_t eSpeakerSize,
                                                        DRV_AudSRSTrusurroundXT_TruBassGain_t eTruBassGain,
                                                        DRV_AudSRSTrusurroundXT_DialogClarityGain_t eDialogClarityGain);

/******************************************************************************/
/**
* @brief    Set ISound configuration
* @param    eIntensityEffect : I-Mono or I-Stereo intensity
* @param    eFadeTime : ISound fade time
* @param    eDetectorTime : ISound detector time
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetISoundConfig(DRV_AudISoundIntensityEffect_t eIntensityEffect,
                                            DRV_AudISoundFadeTime_t eFadeTime,
                                            DRV_AudISoundDetectorTime_t eDetectorTime);

/******************************************************************************/
/**
* @brief    Set SRS 3D sound configuration
* @param    fEnBypass : DTV_TRUE : enable SRS 3D sound bypass
*                       DTV_FALSE : disable SRS 3D sound bypass
* @param    eCenter : SRS 3D sound center Selection
* @param    eSpace : SRS 3D sound space Selection
******************************************************************************/
DRV_Status_t DRV_AudSetSRS3DSoundConfig(Boolean fEnBypass,
                                                DRV_AudSRS3DCenter_t eCenter,
                                                DRV_AudSRS3DSpace_t eSpace);

/******************************************************************************/
/**
* @brief    Set WOW configuration
* @param    eBrightness : SRS WOW brightness control
* @param    eSpeakerSize : SRS WOW speaker size selection
* @param    eBassLevel : SRS WOW bass level control
* @param    eStereoWidth : SRS WOW stereo width control
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSRSWOWConfig(DRV_AudSRSWOWBrightness_t eBrightness,
                                            DRV_AudSRSWOWSpeakerSize_t eSpeakerSize,
                                            DRV_AudSRSWOWBassLevel_t eBassLevel,
                                            DRV_AudSRSWOWStereoWidth_t eStereoWidth);

/******************************************************************************/
/**
* @brief    Set 3D sound configuration
* @param    eBassBoost : BBE contour value at 100 Hz
* @param    eTrebleBoost : BBE process value at 10 kHz
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetBBEConfig(DRV_AudBBEBoost_t eBassBoost,
                                            DRV_AudBBEBoost_t eTrebleBoost);

/******************************************************************************/
/**
* @brief    Set ACC(Acoustical Compensation) configuration
* @param    eProcessPath : specify ACC process path
* @param    a0 : specify ACC parameter a0
* @param    a1 : specify ACC parameter a1
* @param    a2 : specify ACC parameter a2
* @param    b1 : specify ACC parameter b1
* @param    b2 : specify ACC parameter b2
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetACCConfig(DRV_AudProcessPath_t eProcessPath,
                                            INT32 a0,
                                            INT32 a1,
                                            INT32 a2,
                                            INT32 b1,
                                            INT32 b2);

/******************************************************************************/
/**
* @brief    Set monitor configuration
* @param    eSource : specify monitor source
* @param    eDetectMode : specify monitor detect method
* @param    eMonitorMatrix : specify calulating matrix
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetMonitorConfig(DRV_AudMonitorSource_t eSource,
                                                DRV_AudMonitorMode_t eDetectMode,
                                                DRV_AudMonitorMatrix_t eMonitorMatrix);

/******************************************************************************/
/**
* @brief    Get Monitor Level
* @param    pdRetMonitorLevel : monitor level report
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_FAILURE if pointer variable is DTV_NULL
******************************************************************************/
DRV_Status_t DRV_AudGetMonitorLevel(INT32 *pdRetMonitorLevel);

/******************************************************************************/
/**
* @brief    Set Beeper configuration
* @param    eProcessPath : specify main,center,surround,AUX1,AUX2,AUX3 process path
*                          to output beeper sound
* @param    wBeeperVolume :  -84(mute) ~ 0(0 dB),(1 step is 1 dB)
* @param    eBeeperFrequency : specify beeper frequency
* @param    eBeeperMode : specify beeper mode
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetBeeperConfig(DRV_AudProcessPath_t eProcessPath,
                                            INT16 wBeeperVolume,
                                            DRV_AudBeeperFrequency_t eBeeperFrequency,
                                            DRV_AudBeeperMode_t eBeeperMode);

/******************************************************************************/
/**
* @brief    Set Silence Detection configuration
* @param    eChannel : only main and AUX1 process path have this function
* @param    fEnSilenceDetection : DTV_TRUE : enable auto silence detection
*			       	         	  DTV_FALSE : disable auto silence detection
* @param    eThreshold : config silence detect threshold
* @param    eDelay : config delay time for this function
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
*******************************************************************************/
DRV_Status_t DRV_AudSetSilenceDetectionConfig(DRV_AudSilenceDetectionChannel_t eChannel,
														Boolean fEnSilenceDetection,
                                                      	DRV_AudSilenceDetectionThreshold_t eThreshold,
                                                      	DRV_AudSilenceDetectionDelay_t eDelay);

/******************************************************************************/
/**
* @brief    Set audio line-in ADC PGA gain
* @param    bPGA_gain : -25(mute) ~ 6(6 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetLineInADCPGAGain(INT8 bPGA_gain);

/******************************************************************************/
/**
* @brief    Get audio line-in ADC PGA gain
* @param    pbPGA_gain : -25(mute) ~ 6(6 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudGetLineInADCPGAGain(INT8 *pbPGA_gain);

/******************************************************************************/
/**
* @brief    Set audio SIF ADC PGA gain
* @param    bPGA_gain : -6(mute) ~ 25(25 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSIFADCPGAGain(INT8 bPGA_gain);

/******************************************************************************/
/**
* @brief    Get audio SIF ADC PGA gain
* @param    pbPGA_gain : -6(mute) ~ 25(25 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudGetSIFADCPGAGain(INT8 *pbPGA_gain);

/******************************************************************************/
/**
* @brief    Set audio SIF AGC
* @param    fEnAGC : DTV_TRUE : enable AGC
*				   DTV_FALSE : disable AGC
* @param    fHysteresisFastMode : DTV_TRUE : Hysteresis is fast mode
*								DTV_FALSE : Hysteresis is slow mode
* @param    bGain : SIF AGC gain, -6(mute) ~ 25(25 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudSetSIFAGCConfig(Boolean fEnAGC,
                                            Boolean fHysteresisFastMode,
                                            INT8 bGain);

/******************************************************************************/
/**
* @brief    Get audio SIF AGC gain
* @param    pbRetGain : SIF AGC status report, -6(mute) ~ 25(25 dB),(1 step is 1 dB)
* @return   DTV_DRV_SUCCESS if successful
*			DTV_DRV_ERR_INVALID_PARAM if parameters is unknown or out of range
******************************************************************************/
DRV_Status_t DRV_AudGetSIFAGCGain(INT8 *pbRetGain);

#else
/******************************************************************************/
/**
* @brief  This function read data from SSD with assigned address
* @param  dSSDAddr         SSD DTL Address
* @param  dSSDDataBitMask  SSD data mask
* @param  bSSDDataBitIndex lowest bit index of SSD data (0..31)
* @param  dSSDData         SSD data
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudReadSSDReg(Uint32 dSSDAddr,
                    Uint32 dSSDDataBitMask,
                    Uint8 bSSDDataBitIndex,
                    Uint32 *pRetData);

void DTV_DRV_SSD_DTL_Read(Uint32 dDTLAddr, Uint32 *pdDTLData);

void DTV_DRV_SSD_DTL_Write(Uint32 dDTLAddr, Uint32 dDTLData);

/******************************************************************************/
/**
* @brief  global power control
* @param DTV_DRV_AudPowerControl_t ePowerControl : power control parameter
* @return   DTV_DRV_SUCCESS if successful
			DTV_DRV_ERR_INVALID_PARAM if the parameter is wrong
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetPowerControl(DTV_DRV_AudPowerControl_t ePowerControl);

/******************************************************************************/
/**
* @brief  SSD initial
* @param DTV_DRV_AudInitialConfig_t *pInitialParam
		 pInitialParam->LipSyncMemoryStarAddress : memory star address for lip sync
		 pInitialParam->LipSyncMemorySize : memory size for lip sync
* @return   DTV_DRV_SUCCESS if successful
			DTV_DRV_ERR_INVALID_PARAM if the initial parameter is wrong
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudInit(DTV_DRV_AudInitialConfig_t *pInitialParam);

/******************************************************************************/
/**
* @brief  SSD un-initial
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudUninit(void);

/******************************************************************************/
/**
* @brief  Get SSD feature version
* @param DTV_DRV_AudFeatureVersion_t *RetFeatureVersion : feature verion
* @return   DTV_DRV_SUCCESS if successful
			DTV_DRV_ERR_FAILURE if parameters is unknown or pointer variable is DTV_NULL
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetSSDFeatureVersion(DTV_DRV_AudFeatureVersion_t *RetFeatureVersion);

/******************************************************************************/
/**
* @brief Set magnitude detect configuration
* @param Boolean fEnAdapter : DTV_TRUE : enable FM overmodulation adaptation
*                             DTV_FALSE : disable FM overmodulation adaptation
* @param Uint8 bFilterBanndWidth : active if bFilterBanndWidth = DTV_TRUE
*                                  0 = narrow
*								   2 = medium
*								   3 = wide
*                                  1 = extra wide (only ch. 1 active)
* @param Uint8 bLevelThershold : active if bFilterBanndWidth = DTV_TRUE
*                                0 = +3 dB = -12 dBFS
*                                1 = +6 dB = - 9 dBFS
*                                2 = +9 dB = -6 dBFS
*                                3 = +12 dB= -3 dBFS
* @param Uint8 bAttenuation : active if bFilterBanndWidth = DTV_FALSE
*                             0(0 dB) ~ 31(31 dB) attenuation of analog standard
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetOverModulationAdapterConfig(Boolean fEnAdapter,
															Uint8 bFilterBanndWidth,
															Uint8 bLevelThershold,
															Uint8 bAttenuation);

/******************************************************************************/
/**
* @brief Set magnitude detect configuration
* @param INT8 bCarrier1_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),threshold for detection of first sound carrier (SC1) during ASD first step, relative to -30 dBFS. -16 prevents ASD "failure" to produce output regardless of carrier level.
* @param Uint8 bMPX_threshold_low : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),lower threshold for MPX pilot detection (BTSC, FM RADIO) in dB below nominal level
* @param Uint8 bMPX_threshold_up : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),upper threshold for MPX pilot detection (BTSC, FM RADIO) in dB below nominal level
* @param Uint8 bSAP_threshold_low : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),lower threshold for SAP carrier detection in dB below nominal level
* @param Uint8 bSAP_threshold_up : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),upper threshold for SAP carrier detection in dB below nominal level
* @param Boolean fEnSub_carrier_detect : DTV_TRUE : enable EIAJ sub carrier detect
*                                        DTV_FALSE : disable EIAJ sub carrier detect
* @param Uint8 bEIAJ_sub_carrier_threshold_low : 0(0 dB) ~ 15(+15),(1 step is 1 dB),lower threshold for EIAJ SUB carrier detection in dB below nominal level
* @param Uint8 bEIAJ_sub_carrier_threshold_up : 0(0 dB) ~ 15(+15),(1 step is 1 dB),upper threshold for EIAJ SUB carrier detection in dB below nominal level
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMagnitudeDetectConfig(INT8 bCarrier1_threshold,
                                                        Uint8 bMPX_threshold_low,
                                                        Uint8 bMPX_threshold_up,
                                                        Uint8 bSAP_threshold_low,
                                                        Uint8 bSAP_threshold_up,
                                                        Boolean fEnSub_carrier_detect,
                                                        Uint8 bEIAJ_sub_carrier_threshold_low,
                                                        Uint8 bEIAJ_sub_carrier_threshold_up);

/******************************************************************************/
/**
* @brief Set SAP auto mute configuration
* @param INT8 bSAP_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of SAP (-16 means automute off)
* @param Uint8 bSAP_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of SAP
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSAPAutoMuteConfig(INT8 bSAP_nmute_threshold,
                                                    Uint8 bSAP_nmute_hysteresis);

/******************************************************************************/
/**
* @brief Set FM/A2 sound carrier 2 auto mute configuration
* @param INT8 bFM_A2_sc2_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of SC2 in FM A2 standards     (-16 means automute off)
* @param Uint8 bFM_A2_sc2_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of SC2 in FM A2 standards
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetFMA2Carrier2AutoMuteConfig(INT8 bFM_A2_sc2_nmute_threshold,
                                                            Uint8 bFM_A2_sc2_nmute_hysteresis);

/******************************************************************************/
/**
* @brief Set BTSC auto mute configuration
* @param INT8 bBTSC_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of BTSC stereo carrier (-16 means automute off)
* @param Uint8 bBTSC_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of BTSC stereo
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBTSCAutoMuteConfig(INT8 bBTSC_nmute_threshold,
                                                    Uint8 bBTSC_nmute_hysteresis);

/******************************************************************************/
/**
* @brief Set FM radio auto mute configuration
* @param INT8 bFM_radio_nmute_threshold : -16(-16 dB) ~ 15(+15 dB),(1 step is 1 dB),noise threshold for automute of FM RADIO stereo carrier (-16 means automute off)
* @param Uint8 bFM_radio_nmute_hysteresis : 0(0 dB) ~ 15(+15 dB),(1 step is 1 dB),hysteresis size [dB] for automute of FM RADIO stereo
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetFMRadioAutoMuteConfig(INT8 bFM_radio_nmute_threshold,
                                                        Uint8 bFM_radio_nmute_hysteresis);

/******************************************************************************/
/**
* @brief Set EIAJ sub carrier auto mute configuration
* @param INT8 bSub_carrier_nmute_threshold : -16(-16 dB) ~ 15(+15),(1 step is 1 dB),noise threshold for automute of EIAJ FM subcarrier (-16 means automute off)
* @param Uint8 bSub_carrier_nmute_hysteresis : 0(0 dB) ~ 15(+15),(1 step is 1 dB),hysteresis size [dB] for automute of EIAJ FM subcarrier
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetEIAJSubCarrierAutoMuteConfig(INT8 bSub_carrier_nmute_threshold,
                                                            Uint8 bSub_carrier_nmute_hysteresis);

/******************************************************************************/
/**
* @brief Set NICAM configuration
* @param Boolean fEnOnly_related : DTV_TRUE : enable to reproduce only related NICAM on DEC output (DDEP only)
*                                  DTV_FALSE : disable to reproduce only related NICAM on DEC output (DDEP only)
* @param Boolean fEnDeemphasis : DTV_TRUE : enable NICAM deemphasis (J17) (all modes)
*                                DTV_FALSE : disable NICAM deemphasis (J17) (all modes)
* @param Boolean fEnAuto_mute : DTV_TRUE : enable NICAM auto mute function depending on bit error rate (DDEP only)
*                               DTV_FALSE : disable NICAM auto mute function depending on bit error rate (DDEP only)
* @param Uint8 bLower_error_limit : 0 ~ 255,NICAM lower error limit (DDEP only)
* @param Uint8 bUpper_error_limit : 0 ~ 255,NICAM upper error limit (DDEP only)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetNICAMConfig(Boolean fEnOnly_related,
                                            Boolean fEnDeemphasis,
                                            Boolean fEnAuto_mute,
                                            Uint8 bLower_error_limit,
                                            Uint8 bUpper_error_limit);

/******************************************************************************/
/**
* @brief Set NICAM QPSK rotate angle, only for I NICAM standard
* @param DTV_DRV_AudNICAMRotateAngle_t eRotateAngel : rotate angle for I NICAM
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetINICAMRotateAngle(DTV_DRV_AudNICAMRotateAngle_t eRotateAngle);

/******************************************************************************/
/**
* @brief  Set DEMDEC Standard Detection Action
* @param DTV_DRV_AudDEMDECResetAction_t eAction : star/release DEMDEC stardard detect
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDetectStandard(DTV_DRV_AudDEMDECResetAction_t eAction);

/******************************************************************************/
/**
* @brief Get Detected Audio Standard from SSD
* @param DTV_DRV_AudStandard_t *pRetAudioStandard : report IF sound standard
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetStandard(DTV_DRV_AudStandard_t *pRetAudioStandard);

/******************************************************************************/
/**
* @brief Get If SAP Mode
* @param Boolean *pfRetSAP : report if SAP detected
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetIfSAP(Boolean *pfRetSAP);

/******************************************************************************/
/**
* @brief Get If Dual(Bilingual) Mode
* @param Boolean *pfRetDual : report if (bilingual) detected
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetIfDual(Boolean *pfRetDual);

/******************************************************************************/
/**
* @brief Get If Stereo Mode
* @param Boolean *pfRetStereo : report if stereo detected
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetIfStereo(Boolean *pfRetStereo);

/******************************************************************************/
/**
* @brief Get If NICAM Mode
* @param Boolean  *pfRetNicam : report if Nicam detected
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetIfNICAM(Boolean *pfRetNicam);

/******************************************************************************/
/**
* @brief  Get front end register values
* @param DTV_DRV_AudFrontEndReg_t  *pfRetFrontEndReg : report if front end register values
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetFrontEndRegInfo(DTV_DRV_AudFrontEndReg_t *pfRetFrontEndReg);

/******************************************************************************/
/**
* @brief  Set static standard selection
* @param DTV_DRV_AudBTSCDBXMode_t mode : select DBX NR mode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBTSCDBXMode(DTV_DRV_AudBTSCDBXMode_t mode);

/******************************************************************************/
/**
* @brief  Set standard group for DEMDEC auto detect
* @param DTV_DRV_AudAutoStandardGroup_t eAutoStandardGroup
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetAutoStandardSelection(DTV_DRV_AudAutoStandardGroup_t eAutoStandardGroup);

/******************************************************************************/
/**
* @brief  Set static standard selection
* @param DTV_DRV_AudStaticStandardSelection_t eStaticStandard
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetStaticStandardSelection(DTV_DRV_AudStaticStandardSelection_t eStaticStandard);

/******************************************************************************/
/**
* @brief Set path adjust level
* @param INT8 bDECAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param INT8 bMonoAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param INT8 bNICAMAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param INT8 bSAPAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param INT8 bADCAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
* @param INT8 bDigitalAdjustLevel : -16(-16 dB, mute) ~ 15(+15 dB),(1 step, 1 db),
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetPathAdjustLevel(INT8 bDECAdjustLevel,
                                                INT8 bMonoAdjustLevel,
                                                INT8 bNICAMAdjustLevel,
                                                INT8 bSAPAdjustLevel,
                                                INT8 bADCAdjustLevel,
                                                INT8 bDigitalAdjustLevel);

/******************************************************************************/
/**
* @brief  Set Digital Divider
* @param DTV_DRV_AudDigitalDivider_t DigitalDividerMode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDigitalDivider(DTV_DRV_AudDigitalDivider_t eDigitalDividerMode);

/******************************************************************************/
/**
* @brief  Set SSD Digital Input Deemphasis
* @param DTV_DRV_AudDigitalDeemphasis_t eDigital_Deemphasis_type :
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDigitalInputDeemphasis(DTV_DRV_AudDigitalDeemphasis_t eDigital_Deemphasis_type);

/******************************************************************************/
/**
* @brief  Set SSD Digital Matrix
* @param DTV_DRV_AudProcessPath_t eProcessPath : SSD Process Channel
* @param DTV_DRV_AudDigitalMatrix_t eDigitalMatrix : SSD Digital Matrix
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDigitalMatrix(DTV_DRV_AudProcessPath_t eProcessPath,
                                 DTV_DRV_AudDigitalMatrix_t eDigitalMatrix);

/******************************************************************************/
/**
* @brief  Set IF Channel MUX
* @param DTV_DRV_AudIFInput_t eIFSource : IFSource IF input
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetIFInput(DTV_DRV_AudIFInput_t eIFSource);

/******************************************************************************/
/**
* @brief  Set ADC Channel MUX
* @param DTV_DRV_AudADCInput_t eADCSource : ADC Source for Analog input
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetADCInput(DTV_DRV_AudADCInput_t eADCSource);

/******************************************************************************/
/**
* @brief  Set Digital Channel
* @param DTV_DRV_AudDigitalInput_t eDigitalSource : DigitalSource Digital Input
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDigitalInput(DTV_DRV_AudDigitalInput_t eDigitalSource);

/******************************************************************************/
/**
* @brief  Set SSD SRC Path
* @param DTV_DRV_AudSRCPath_t eSRCPath : SSD Input Channel
* @param DTV_DRV_AudSRCSource_t eSRCSource : SSD Input Channel Source
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSRCPath(DTV_DRV_AudSRCPath_t eSRCPath,
                           DTV_DRV_AudSRCSource_t eSRCSource);

/******************************************************************************/
/**
* @brief Set SSD Signal Source for Sound Process Path
* @param DTV_DRV_AudProcessPath_t eMainAUXPath : SSD Process Channel
* @param DTV_DRV_AudProcessSource_t eSource : SSD Process Channel Source
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainAUXPath(DTV_DRV_AudProcessPath_t eMainAUXPath,
                               DTV_DRV_AudMainAUXSource_t eSource);


/******************************************************************************/
/**
* @brief Set SSD Signal Source for Sound Process Path
* @param DTV_DRV_AudProcessPath_t eCenterSurroundPath : SSD Process Channel
* @param DTV_DRV_AudCenterSurroundSource_t eSource :  SSD Process Channel Source
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterSurroundPath(DTV_DRV_AudProcessPath_t eCenterSurroundPath,
                               DTV_DRV_AudCenterSurroundSource_t eSource);

/******************************************************************************/
/**
* @brief Set DAC as auto-sleep mode
* @param Boolean fEn : DTV_TRUE : enable DAC auto sleep
*            		   DTV_FALSE : disable DAC auto sleep
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDACAutoSleep(Boolean fEn);

/******************************************************************************/
/**
* @brief Set SSD Output Path
* @param DTV_DRV_AudSSDOutputPath_t eOutputChannel : ouput channel selection
* @param DTV_DRV_AudSSDOutputSource_t eOutputLeftChannelSource : source for output left channel
* @param DTV_DRV_AudSSDOutputSource_t eOutputRightChannelSource : source for output right channel
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetOutputPath(DTV_DRV_AudSSDOutputPath_t eOutputChannel,
                              DTV_DRV_AudSSDOutputSource_t eOutputLeftChannelSource,
                              DTV_DRV_AudSSDOutputSource_t eOutputRightChannelSource);

/******************************************************************************/
/**
* @brief Initialize I2S output crossbar
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudI2SOutputCrossbarInit(void);

/******************************************************************************/
/**
* @brief  Set SSD SPDIF bypass
* @param  Boolean fEnBitClockInvert : DTV_TRUE : enable bit clock inverse
*                       			  DTV_FALSE : disable bit clock inverse
* @param  DTV_DRV_AudSSDOutputPath_t SSDOutPut : select SSD output channel to change I2S format,
*                                                DTV_DRV_AUD_SSD_OUTPUT_SD0 and DTV_DRV_AUD_SSD_OUTPUT_SD1 will be the same format
* @param  DTV_DRV_AudI2SOutputFormat_t Format : I2S format selection
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetI2SOutputFormat(Boolean fEnBitClockInvert,
												DTV_DRV_AudSSDOutputPath_t SSDOutPut,
												DTV_DRV_AudI2SOutputFormat_t Format);


/******************************************************************************/
/**
* @brief  Set SSD SPDIF bypass
* @param  Boolean fEn : DTV_TRUE : enable bypass SPDIF,
*                       DTV_FALSE : disable bypass SPDIF
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSPDIFPathBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief  Get SSD SPDIF bypass
* @param  Boolean fEn : DTV_TRUE : SPDIF bypass is enable,
*                       DTV_FALSE : SPDIF bypass is disable,
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetIfSPDIFPathBypass(Boolean* fRetEn);

/******************************************************************************/
/**
* @brief  Set SSD I2S bypass
* @param  Boolean fEn : DTV_TRUE : enable bypass I2S,
*                       DTV_FALSE : disable bypass I2S
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetI2SPathBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief  Set SSD Main Path Mixer
* @param  DTV_DRV_AudMainPathMixer_t eMainPathMixer : main path mixer selection
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainPathMixer(DTV_DRV_AudMainPathMixer_t eMainPathMixer);

/******************************************************************************/
/**
* @brief  Set DEMDEC Output Mute
* @param  Boolean fEn : DTV_TRUE : Mute On
*             DTV_FALSE : Mute Off
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDEMDECMute(Boolean fEn);

/******************************************************************************/
/**
* @brief  Get DEMDEC Output Mute
* @param Boolean *pfRetMute : DTV_TRUE : Mute On
*                   DTV_FALSE : Mute Off
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetDEMDECMute(Boolean *pfRetMute);

/******************************************************************************/
/**
* @brief Set Mute
* @param Boolean fEn : DTV_TRUE : mute path
*                      DTV_FALSE : unmute path
* @param DTV_DRV_AudMutePath_t eMutePath :  process path for mute
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMutePath(DTV_DRV_AudMutePath_t eMutePath,
                                        Boolean fEn);

/******************************************************************************/
/**
* @brief Set Master Volume
* @param Sint16 wMasterVolume : -672(mute) ~ 192 (+192 dB),(1 step is 0.125 dB), controls MAIN, SW, C and S in 1/8dB steps
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMasterVolume(Sint16 wMasterVolume);

/******************************************************************************/
/**
* @brief Get master volume value
* @param Sint16 *pwRetMasterVolume : return master volume value
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMasterVolume(Sint16 *pwRetMasterVolume);

/******************************************************************************/
/**
* @brief Set Main Volume
* @param INT8 bLeftMainVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param INT8 bRightMainVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainVolume(INT8 bLeftMainVolume,INT8 bRightMainVolume);

/******************************************************************************/
/**
* @brief Get Main Volume
* @param INT8 *pbRetLeftMainVolume : return main left channel volume value
* @param INT8 *pbRetRightMainVolume : return main right channel volume value
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainVolume(INT8 *pbRetLeftMainVolume,INT8 *pbRetRightMainVolume);

/******************************************************************************/
/**
* @brief Set Subwoofer Volume
* @param INT8 bSubwooferVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSubwooferVolume(INT8 bSubwooferVolume);

/******************************************************************************/
/**
* @brief Set Center Volume
* @param INT8 bCenterVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterVolume(INT8 bCenterVolume);

/******************************************************************************/
/**
* @brief Set Surround Volume
* @param INT8 bSurroundVolume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSurroundVolume(INT8 bSurroundVolume);

/******************************************************************************/
/**
* @brief Set AUX1 Volume
* @param INT8 bLeftAUX1Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param INT8 bRightAUX1Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetAUX1Volume(INT8 bLeftAUX1Volume,INT8 bRightAUX1Volume);

/******************************************************************************/
/**
* @brief Set AUX2 Volume
* @param INT8 bLeftAUX2Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param INT8 bRightAUX2Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetAUX2Volume(INT8 bLeftAUX2Volume,INT8 bRightAUX2Volume);

/******************************************************************************/
/**
* @brief Set AUX3 Volume
* @param INT8 bLeftAUX3Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
* @param INT8 bRightAUX3Volume : -84(mute) ~ 24(+24 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetAUX3Volume(INT8 bLeftAUX3Volume,INT8 bRightAUX3Volume);

/******************************************************************************/
/**
* @brief Set Main Bass
* @param INT8 bMainBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainBass(INT8 bMainBass);

/******************************************************************************/
/**
* @brief Get Main Bass
* @param INT8 *pbRetMainBass : return main bass value
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainBass(INT8 *pbRetMainBass);

/******************************************************************************/
/**
* @brief Set Center Bass
* @param INT8 bCenterBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterBass(INT8 bCenterBass);

/******************************************************************************/
/**
* @brief Set Surround Bass
* @param INT8 bSurroundBass : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSurroundBass(INT8 bSurroundBass);

/******************************************************************************/
/**
* @brief Set Main Treble
* @param INT8 bMainTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainTreble(INT8 bMainTreble);

/******************************************************************************/
/**
* @brief get Main Treble
* @param INT8 *pbRetMainTreble : return main treble vaule
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainTreble(INT8 *pbRetMainTreble);

/******************************************************************************/
/**
* @brief Set Center Treble
* @param INT8 bCenterTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterTreble(INT8 bCenterTreble);

/******************************************************************************/
/**
* @brief Set Surround Treble
* @param INT8 bSurroundTreble : -16(-16 dB) ~ 15(+15dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSurroundTreble(INT8 bSurroundTreble);
#if 1
/******************************************************************************/
/**
* @brief Set main equalizer configuration
* @param INT8 bBand1_0100Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand2_000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand3_1000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand4_3000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand5_8000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizer(INT8 bBand1_0100Hz,
                                                INT8 bBand2_000Hz,
                                                INT8 bBand3_1000Hz,
                                                INT8 bBand4_3000Hz,
                                                INT8 bBand5_8000Hz);

/******************************************************************************/
/**
* @brief Get main equalizer configuration
* @param INT8 *pbRetBand1_0100Hz : return value of 0100 Hz main equalizer band
* @param INT8 *pbRetBand2_0300Hz : return value of 0300 Hz main equalizer band
* @param INT8 *pbRetBand3_1000Hz : return value of 1000 Hz main equalizer band
* @param INT8 *pbRetBand4_3000Hz : return value of 3000 Hz main equalizer band
* @param INT8 *pbRetBand5_8000Hz : return value of 8000 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizer(INT8 *pbRetBand1_0100Hz,
                                                INT8 *pbRetBand2_0300Hz,
                                                INT8 *pbRetBand3_1000Hz,
                                                INT8 *pbRetBand4_3000Hz,
                                                INT8 *pbRetBand5_8000Hz);

/******************************************************************************/
/**
* @brief Set center equalizer configuration
* @param INT8 bBand1_0100Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand2_0300Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand3_1000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand4_3000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
* @param INT8 bBand5_8000Hz : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizer(INT8 bBand1_0100Hz,
                                                INT8 bBand2_000Hz,
                                                INT8 bBand3_1000Hz,
                                                INT8 bBand4_3000Hz,
                                                INT8 bBand5_8000Hz);
/******************************************************************************/
/**
* @brief Get center equalizer configuration
* @param INT8 *pbRetBand1_0100Hz : return value of 0100 Hz main equalizer band
* @param INT8 *pbRetBand2_0300Hz : return value of 0300 Hz main equalizer band
* @param INT8 *pbRetBand3_1000Hz : return value of 1000 Hz main equalizer band
* @param INT8 *pbRetBand4_3000Hz : return value of 3000 Hz main equalizer band
* @param INT8 *pbRetBand5_8000Hz : return value of 8000 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizer(INT8 *pbRetBand1_0100Hz,
                                                INT8 *pbRetBand2_0300Hz,
                                                INT8 *pbRetBand3_1000Hz,
                                                INT8 *pbRetBand4_3000Hz,
                                                INT8 *pbRetBand5_8000Hz);
#else
/******************************************************************************/
/**
* @brief Set Main Equalizer Band1_0100HZ
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizerBand1_0100Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchm1,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchm1, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Main Equalizer Band2_0300HZ
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizerBand2_0300Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchm2,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchm2, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Main Equalizer Band3_1000Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizerBand3_1000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchm3,bEQValue);
	HW_SSDSetReg(REG_Ssd_eqchm3, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Main Equalizer Band4_0100Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizerBand4_3000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchm4,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchm4, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Main Equalizer Band5_8000Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainEqualizerBand5_8000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchm5,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchm5, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Main Equalizer Band1_0100HZ
* @param INT8 *pbRetEQValue : return value of 100 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizerBand1_0100Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchm1,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Main Equalizer Band2_0300HZ
* @param INT8 *pbRetEQValue : return value of 300 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizerBand2_0300Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchm2,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Main Equalizer Band3_1000Hz
* @param INT8 *pbRetEQValue : return value of 1000 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizerBand3_1000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchm3,*pbRetEQValue);
    return DTV_DRV_SUCCESS;

}

/******************************************************************************/
/**
* @brief Get Main Equalizer Band4_3000Hz
* @param INT8 *pbRetEQValue : return value of 3000 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizerBand4_3000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchm4,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Main Equalizer Band5_8000Hz
* @param INT8 *pbRetEQValue : return value of 8000 Hz main equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainEqualizerBand5_8000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchm5,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Center Equalizer Band1_0100HZ
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizerBand1_0100Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchc1,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchc1, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Center Equalizer Band2_0300HZ
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizerBand2_0300Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchc2,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchc2, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Center Equalizer Band3_1000Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizerBand3_1000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchc3,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchc3, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Center Equalizer Band4_3000Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizerBand4_3000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchc4,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchc4, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Set Center Equalizer Band5_8000Hz
* @param INT8 bEQValue : -12(-12 dB) ~ 12(+12dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetCenterEqualizerBand5_8000Hz(INT8 bEQValue)
{
	HW_SSDCheckRegRange(REG_Ssd_eqchc5,bEQValue);
    HW_SSDSetReg(REG_Ssd_eqchc5, bEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Center Equalizer Band1_0100HZ
* @param INT8 *pbRetEQValue : return value of 100 Hz center equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizerBand1_0100Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchc1,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Center Equalizer Band2_0300HZ
* @param INT8 *pbRetEQValue : return value of 300 Hz center equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizerBand2_0300Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchc2,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Center Equalizer Band3_1000Hz
* @param INT8 *pbRetEQValue : return value of 1000 Hz center equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizerBand3_1000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchc3,*pbRetEQValue);
    return DTV_DRV_SUCCESS;

}

/******************************************************************************/
/**
* @brief Get Center Equalizer Band4_3000Hz
* @param INT8 *pbRetEQValue : return value of 3000 Hz center equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizerBand4_3000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchc4,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}

/******************************************************************************/
/**
* @brief Get Center Equalizer Band5_8000Hz
* @param INT8 *pbRetEQValue : return value of 8000 Hz center equalizer band
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetCenterEqualizerBand5_8000Hz(INT8 *pbRetEQValue)
{
    HW_SSDSignExpand(REG_Ssd_eqchc5,*pbRetEQValue);
    return DTV_DRV_SUCCESS;
}
#endif
/******************************************************************************/
/**
* @brief Set Main and Center Equalizer Bypass
* @param Boolean fEn : Enable/Disable main and center equalizer bypass
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainCenterEQBypass(Boolean fEn);

/******************************************************************************/
/**
* @brief get Main and Center Equalizer Bypass
* @param Boolean *pfRetEn : return main and center equalizer bypass enable/disable
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMainCenterEQBypass(Boolean *pfRetEn);

/******************************************************************************/
/**
* @brief Set Effect Mode
* @param DTV_DRV_AudEffectMod_t eEffectMode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetEffectMode(DTV_DRV_AudEffectMode_t eEffectMode);

/******************************************************************************/
/**
* @brief  Set Spatial Effect
* @param DTV_DRV_AudSpatialEffect_t eSpatialEffect
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSpatialEffect(DTV_DRV_AudSpatialEffect_t eSpatialEffect);

/******************************************************************************/
/**
* @brief  Set SRS Spatializer Selector
* @param DTV_DRV_AudSRSSpatializer_t eSpatializerSelect
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSRSSpatialSelector(DTV_DRV_AudSRSSpatializer_t eSpatializerSelect);

/******************************************************************************/
/**
* @brief  Set Bass Feature Control
* @param DTV_DRV_AudBassFeature_t eBassFeature
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBassFeatureControl(DTV_DRV_AudBassFeatureControl_t eBassFeature);

/******************************************************************************/
/**
* @brief  Set Subwoofer Mode
* @param DTV_DRV_AudSubwooferMode_t eSubwooferMode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSubwooferMode(DTV_DRV_AudSubwooferMode_t eSubwooferMode);

/******************************************************************************/
/**
* @brief Set AVL configuration
* @param DTV_DRV_AudAVLMode_t eMode : DTV_DRV_AudAVLMMode_t : AVL Mode Control
* @param INT8 bReference_level : 0 (-6 dBFS)~ 15(-36 dBFS),AVL reference level
*                                 2 = high threshold | (-10 dBFS), small reduction ("daytime mode")
*                                 7 = medium threshold | (-20 dBFS), medium reduction ("evening mode")
*                                 12 = low threshold | (-30 dBFS), strong reduction ("night mode")
* @param Boolean fEnWeightFilter : Enable/Disable weight filter
* @param Boolean fEnPeakModeWithClipManagement :Enable/Disable Peak Mode With Clip Management
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetAVLConfig(DTV_DRV_AudAVLMode_t eMode,
                                            INT8 bReference_level,
                                            Boolean fEnWeightFilter,
                                            Boolean fEnPeakModeWithClipManagement);

/******************************************************************************/
/**
* @brief Set Main Loudness configuration
* @param Boolean fEnMainLoudness : DTV_TRUE : enable mainloudness process
*                                  DTV_FALSE : disable mainloudness process
* @param Boolean fEnExtraBass : Enable : filter character is 1000 Hz,Disable : filter character is 500 Hz
* @param DTV_DRV_AudMainLoudnessVolumeLevel_t NoneAttackVolumeLevel : Main Loudness None Attack Volume Level
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMainLoudnessConfig(Boolean fEnMainLoudness,
                                                    Boolean fEnExtraBass,
                                                    DTV_DRV_AudMainLoudnessVolumeLevel_t eNoneAttackVolumeLevel);

/******************************************************************************/
/**
* @brief Set Delay Line Unit configuration
* @param Boolean fEn : DTV_TRUE : enable delay line unit process
*                      DTV_FALSE : disable delay line unit process
* @param Uint8 bDlu_delay : 0 ~ 63(1 step is 4 ms)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDelayLineUnitConfig(Boolean fEn,Uint8 bDlu_delay);

/******************************************************************************/
/**
* @brief Set Delay Line Unit Mux
* @param Boolean fEn : DTV_TRUE : enable AUX1 ~ delay line unit process
*                      DTV_FALSE : disable delay line unit process
* @param DTV_DRV_AudMuxType_t MuxType : DTV_DRV_AUD_ADC_INPUT
*                                       DTV_DRV_AUD_DIGITAL_INPUT
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetDelayLineUnitMux(Boolean fEn,DTV_DRV_AudMuxType_t MuxType);

/******************************************************************************/
/**
* @brief Set Clip Management Mode
* @param DTV_DRV_AudClipManagementMode_t eClipManagementMode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetClipManagementMode(DTV_DRV_AudClipManagementMode_t eClipManagementMode);

/******************************************************************************/
/**
* @brief Set Clip Management configuration DVM Config
* @param DTV_DRV_AudDVMPeakDetectionSelection_t ePeakDetectSelection : clip management peakdetection selection
* @param Uint8 bRelease_range_upper_limit : 0 ~ 3,dynamic volume mode release range upper limit (clip management)
*                                           0 = -3,5dBFS
*                                           1 = -6dBFS
*                                           2 = -9dBFS
*                                           3 = -12dBFS
* @param Uint8 bRelease_range_lower_limit : 0 ~ 3,dynamic volume mode release range lower limit (clip management)
*                                           0 = -40dBFS
*                                           1 = -50dBFS
*                                           2 = -60dBFS
*                                           3 = -inf
* @param Uint8 bAttack_speed : 0 ~ 1,dynamic volume mode attack speed
*                              0 = 4.8dB/s
*                              1 = 9.6dB/s
* @param Uint8 bRelease_speed : 0 ~ 3,dynamic volume mode release speed
*                               0 = 0.06dB/s
*                               1 = 0.12dB/s
*                               2 = 0.24dB/s
*                               3 = 0.48dB/s
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetClipManagementDVMConfig(DTV_DRV_AudDVMPeakDetectionSelection_t ePeakDetectSelection,
                                                        Uint8 bRelease_range_upper_limit,
                                                        Uint8 bRelease_range_lower_limit,
                                                        Uint8 bAttack_speed,
                                                        Uint8 bRelease_speed);

/******************************************************************************/
/**
* @brief Set Bass Management configuration
* @param DTV_DRV_AudBassManagementMode_t eMode : bass management mode
* @param DTV_DRV_AudBassManagementFilterCharacteristic_t eFilterCharacteristic :
*					0 ~ 15,bass management filtercharacteristics (50 - 400hz cornerfrequency)
* @param Boolean fEnSubwooferFilter : DTV_TRUE : enable bass management subwoofer filter control
*                                     DTV_FALSE : disable bass management subwoofer filter control
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBassManagementConfig(DTV_DRV_AudBassManagementMode_t eMode,
                                                    DTV_DRV_AudBassManagementFilterCharacteristic_t eFilterCharacteristic,
                                                    Boolean fEnSubwooferFilter);

/******************************************************************************/
/**
* @brief Set VDSII configuration
* @param DTV_DRV_AudVDSIIEffectLevel_t eEffectLevel : VDSII Effect Level: 0..100% (5 steps)
* @param DTV_DRV_AudVDSIIBalanceControl_t eBalanceControl : VDSII Balance Control
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetVDSIIConfig(DTV_DRV_AudVDSIIEffectLevel_t eEffectLevel,
                                            DTV_DRV_AudVDSIIBalanceControl_t eBalanceControl);

/******************************************************************************/
/**
* @brief Set SRS TruSurround XT Effect configuration
* @param DTV_DRV_AudSRSTrusurroundXT_K_Mode_t eMode : TSXT K Mode selection
* @param Boolean fEnDialogClarity : DTV_TRUE : enable dialog clarity function control
*                                   DTV_FALSE : disable dialog clarity function control
* @param Boolean fEnTruBass : DTV_TRUE : enable Tru Bass function control
*                             DTV_FALSE : disable Tru Bass function control
* @param Boolean fEnHeadphoneControl : DTV_TRUE : enable headphone control
*                                      DTV_FALSE : disable headphone control
* @param Boolean fEnCenterOutputModeControl : DTV_TRUE : enable center output mode control
*                                             DTV_FALSE : disable center output mode control
* @param DTV_DRV_AudSRSTrusurroundXT_SpeakerSize_t eSpeakerSize : speaker size selection
* @param DTV_DRV_AudSRSTrusurroundXT_TruBassGain_t eTruBassGain : trubass gain control
* @param DTV_DRV_AudSRSTrusurroundXT_DialogClarityGain_t eDialogClarityGain : dialog clarity gain control
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSRSTruSurroundXTConfig(DTV_DRV_AudSRSTrusurroundXT_K_Mode_t eMode,
                                                        Boolean fEnDialogClarity,
                                                        Boolean fEnTruBass,
                                                        Boolean fEnHeadphoneControl,
                                                        Boolean fEnCenterOutputMoceControl,
                                                        DTV_DRV_AudSRSTrusurroundXT_SpeakerSize_t eSpeakerSize,
                                                        DTV_DRV_AudSRSTrusurroundXT_TruBassGain_t eTruBassGain,
                                                        DTV_DRV_AudSRSTrusurroundXT_DialogClarityGain_t eDialogClarityGain);

/******************************************************************************/
/**
* @brief Set ISound configuration
* @param DTV_DRV_AudISoundIntensityEffect_t eIntensityEffect : I-Mono or I-Stereo intensity
* @param DTV_DRV_AudISoundFadeTime_t eFadeTime : ISound Fade Time
* @param DTV_DRV_AudISoundDetectorTime_t eDetectorTime : ISound Detector Time
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetISoundConfig(DTV_DRV_AudISoundIntensityEffect_t eIntensityEffect,
                                            DTV_DRV_AudISoundFadeTime_t eFadeTime,
                                            DTV_DRV_AudISoundDetectorTime_t eDetectorTime);

/******************************************************************************/
/**
* @brief Set SRS 3D Sound configuration
* @param Boolean fEnBypass : DTV_TRUE : enable SRS 3D Sound Bypass
*                            DTV_FALSE : disable SRS 3D Sound Bypass
* @param DTV_DRV_AudSRS3DCenter_t eCenter : SRS 3D Sound Center Selection
* @param DTV_DRV_AudSRS3DSpace_t eSpace : SRS 3D Sound Space Selection
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSRS3DSoundConfig(Boolean fEnBypass,
                                                DTV_DRV_AudSRS3DCenter_t eCenter,
                                                DTV_DRV_AudSRS3DSpace_t eSpace);

/******************************************************************************/
/**
* @brief Set WOW configuration
* @param Uint8 bBrightness : SRS WOW brightness control
* @param Uint8 bSpeakerSize : SRS WOW speaker size selection
* @param Uint8 bBassLevel : SRS WOW bass level control
* @param Uint8 bStereoWidth : SRS WOW stereo width control
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSRSWOWConfig(DTV_DRV_AudSRSWOWBrightness_t eBrightness,
                                            DTV_DRV_AudSRSWOWSpeakerSize_t eSpeakerSize,
                                            DTV_DRV_AudSRSWOWBassLevel_t eBassLevel,
                                            DTV_DRV_AudSRSWOWStereoWidth_t eStereoWidth);

/******************************************************************************/
/**
* @brief Set 3D Sound configuration
* @param DTV_DRV_AudBBEBoost_t bBassBoost : BBE contour value at 100 Hz
* @param DTV_DRV_AudBBEBoost_t bTrebleBoost : BBE process value at 10 kHz
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBBEConfig(DTV_DRV_AudBBEBoost_t eBassBoost,
                                            DTV_DRV_AudBBEBoost_t eTrebleBoost);

/******************************************************************************/
/**
* @brief Set ACC(Acoustical Compensation) configuration
* @param DTV_DRV_AudProcessPath_t eProcessPath : specify ACC process path
* @param INT32 a0~b2 : specify ACC parameters
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetACCConfig(DTV_DRV_AudProcessPath_t eProcessPath,
                                            INT32 a0,
                                            INT32 a1,
                                            INT32 a2,
                                            INT32 b1,
                                            INT32 b2);

/******************************************************************************/
/**
* @brief  Set Set Monitor configuration
* @param  DTV_DRV_AudMonitorSource_t eSource
* @param  DTV_DRV_AudMonitorMode_t eDetectMode
* @param  DTV_DRV_AudMonitorMatrix_t eMonitorMatrix
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetMonitorConfig(DTV_DRV_AudMonitorSource_t eSource,
                                                DTV_DRV_AudMonitorMode_t eDetectMode,
                                                DTV_DRV_AudMonitorMatrix_t eMonitorMatrix);

/******************************************************************************/
/**
 * @brief  Get Monitor Level
 * @param  INT32 *pdRetMonitorLevel : monitor level report
 ******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetMonitorLevel(INT32 *pdRetMonitorLevel);

/******************************************************************************/
/**
* @brief  Set Beeper configuration
* @param  Sint16 wBeeperVolume :  -84(mute) ~ 0(0 dB),(1 step is 1 dB)
* @param  DTV_DRV_AudBeeperFrequency_t eBeeperFrequency
* @param  DTV_DRV_AudBeeperMode_t eBeeperMode
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetBeeperConfig(Sint16 wBeeperVolume,
                                            DTV_DRV_AudBeeperFrequency_t eBeeperFrequency,
                                            DTV_DRV_AudBeeperMode_t eBeeperMode);

/******************************************************************************/
/**
 * @brief  Set Silence Detection configuration
 * @param  DTV_DRV_AudSilenceDetectionChannel_t eChannel
 * @param  Boolean fEnSilenceDetection : DTV_TRUE : enable auto silence detection
 *										 DTV_FALSE : disable auto silence detection
 * @param  DTV_DRV_AudSilenceDetectionThreshold_t eThreshold
 * @param  DTV_DRV_AudSilenceDetectionDelay_t eDelay
 ******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSilenceDetectionConfig(DTV_DRV_AudSilenceDetectionChannel_t eChannel,
														Boolean fEnSilenceDetection,
                                                      	DTV_DRV_AudSilenceDetectionThreshold_t eThreshold,
                                                      	DTV_DRV_AudSilenceDetectionDelay_t eDelay);

/******************************************************************************/
/**
* @brief  Set audio ADC PGA gain
* @param  INT8 PGA_gain : -25(mute) ~ 6(6 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetLineInADCPGAGain(INT8 PGA_gain);

/******************************************************************************/
/**
* @brief  Get audio ADC PGA gain
* @param  INT8 PGA_gain : -25(mute) ~ 6(6 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetLineInADCPGAGain(INT8 *PGA_gain);

/******************************************************************************/
/**
* @brief  Set audio SIF ADC PGA gain
* @param  INT8 PGA_gain : -6(mute) ~ 25(25 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSIFADCPGAGain(INT8 PGA_gain);

/******************************************************************************/
/**
* @brief  Get audio SIF AGC gain
* @param  INT8 *pbRetGain : SIF AGC status report, -25(mute) ~ 6(6 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetSIFAGCGain(INT8 *pbRetGain);

/******************************************************************************/
/**
* @brief  Set audio SIF AGC
* @param  Boolean fEnAGC : DTV_TRUE : enable AGC
*						   DTV_FALSE : disable AGC
* @param  Boolean fHysteresisFastMode : DTV_TRUE : Hysteresis is fast mode
*										  DTV_FALSE : Hysteresis is slow mode
* @param  Uint8 bGain : SIF AGC gain, -25(mute) ~ 6(6 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudSetSIFAGCConfig(Boolean fEnAGC,
                                            Boolean fIfHysteresisFastMode,
                                            INT8 bGain);

/******************************************************************************/
/**
* @brief  Get audio SIF AGC gain
* @param  INT8 *pbRetGain : SIF AGC status report, -25(mute) ~ 6(6 dB),(1 step is 1 dB)
******************************************************************************/
DTV_DRV_Status_t DTV_DRV_AudGetSIFAGCGain(INT8 *pbRetGain);

#endif /* __DRV_AUDIO_H__ */

/*!
    @} end of addtogroup Audio */
#endif
