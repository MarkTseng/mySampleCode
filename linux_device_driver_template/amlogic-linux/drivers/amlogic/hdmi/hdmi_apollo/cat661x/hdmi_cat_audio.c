#include "hdmi_cat_defstx.h"#include "hdmi_i2c.h"#include "hdmi_cat_info_set.h"#include "hdmi_cat_audio.h"#include "hdmi_vmode.h"
    #include "hdmi_global.h"#include "hdmi_debug.h"
extern VModeInfoType VModeTables[NMODES];
static unsigned char bPendingAudio = 0;
unsigned char CAT6611_bPendingAudioAdjust = 0;
static unsigned char bAudioEnableSetting = 0;
static unsigned char bAudioPendingCounter = 0;
////////////////////////////////////////////////////////////////////////////////// Function: CAT_SetNCTS// Parameter: PCLK - video clock in Hz.//            Fs - audio sample frequency in Hz// Return: ER_SUCCESS if success// Remark: set N value, the CTS will be auto generated by HW.// Side-Effect: register bank will reset to bank 0.////////////////////////////////////////////////////////////////////////////////static void CAT_SetNCTS(Hdmi_info_para_t * info) {    unsigned long n;
    unsigned long PCLK;    PCLK = VModeTables[info->tv_mode].PixClk * 10000;    hdmi_dbg_print("MCLK = Fs * 256\n");    switch (info->audiopath_sf)    {        case FS_32K://32000:            hdmi_dbg_print("audio sampling frequency is 32k\n");            switch (PCLK)            {                case 74250000:                    n = 11648;                    break;                case 148500000:                    n = 11648;                    break;                default:                    n = 4096;                    break;            }            break;        case FS_44K1://44100:            hdmi_dbg_print("audio sampling frequency is 44.1k\n");            switch (PCLK)            {                case 74250000:                    n = 17836;                    break;                                    case 148500000:                    n = 8918;                    break;                                    default:                    n = 6272;                    break;            }            break;        case FS_48K://48000:            hdmi_dbg_print("audio sampling frequency is 48k\n");            switch (PCLK)            {                case 74250000:                    n = 11648;                    break;                                    case 148500000:                    n = 5824;                    break;                default:                    n = 6144;                    break;            }            break;        case FS_88K2://88200:            hdmi_dbg_print("audio sampling frequency is 88.2k\n");
            switch (PCLK)            {                case 74250000:                    n = 35672;                    break;                case 148500000:                    n = 17836;                    break;                default:                    n = 12544;                    break;            }
            break;        case FS_96K://96000:            hdmi_dbg_print("audio sampling frequency is 96k\n");            switch (PCLK)            {
                case 74250000:                    n = 23296;                    break;                case 148500000:                    n = 11648;                    break;                default:                    n = 12288;                    break;            }            break;        case FS_176K4://176400:            hdmi_dbg_print("audio sampling frequency is 176.4k\n");            switch (PCLK)
            {                case 74250000:                    n = 71344;                    break;                                    case 148500000:                    n = 35672;                    break;                                    default:                    n = 25088;                    break;            }            break;            case FS_192K://192000:            hdmi_dbg_print("audio sampling frequency is 192k\n");            switch (PCLK)            {                case 74250000:                    n = 46592;                    break;                                    case 148500000:                    n = 23296;                    break;                default:                    n = 24576;                    break;            }            break;        default:
            hdmi_dbg_print("audio sampling frequency is forced to 44.1k\n");            n = 6272;            info->audiopath_sf = FS_44K1;            break;    }
	    CAT_Switch_HDMITX_Bank(TX_SLV0, 1);//select bank 1    WriteByteHDMITX_CAT(REGPktAudN0, (unsigned char)((n) & 0xFF));    WriteByteHDMITX_CAT(REGPktAudN1, (unsigned char)((n >> 8) & 0xFF));    WriteByteHDMITX_CAT(REGPktAudN2, (unsigned char)((n >> 16) & 0xF));
   //printf("N value is %5d \n", n);        CAT_Switch_HDMITX_Bank(TX_SLV0, 0);//select bank 0    WriteByteHDMITX_CAT(REG_PKT_SINGLE_CTRL, 0);// D[1] = 0, HW auto count CTS    WriteByteHDMITX_CAT(REG_CLK_CTRL0,
((ReadByteHDMITX_CAT(REG_CLK_CTRL0)) & (~M_EXT_MCLK_SEL)) | B_EXT_256FS);
} //unsigned FS_32K_flag = 0;//unsigned FS_44_1K_flag = 0;//unsigned FS_48K_flag = 0;//unsigned FS_88_2K_flag = 0;//unsigned FS_96K_flag = 0;//unsigned FS_176_8K_flag = 0;//unsigned FS_192K_flag = 0;
int CAT_AdjustAudioSampleClock(Hdmi_info_para_t * info) {    unsigned char fs, uc;    unsigned long N = 0, CTS = 0, SampleFreq = 0;    //float temp_sample= 0.0;    long temp_sample = 0;    CAT6611_bPendingAudioAdjust = 1;    CAT_Switch_HDMITX_Bank(TX_SLV0, 1);//select bank 1        N = ((unsigned long)ReadByteHDMITX_CAT(REGPktAudN2) & 0xF) << 16;    N |= ((unsigned long)ReadByteHDMITX_CAT(REGPktAudN1)) << 8;    N |= ((unsigned long)ReadByteHDMITX_CAT(REGPktAudN0));    CTS =
((unsigned long)ReadByteHDMITX_CAT(REGPktAudCTSCnt2) & 0xF) << 16;    CTS |= ((unsigned long)ReadByteHDMITX_CAT(REGPktAudCTSCnt1)) << 8;    CTS |= ((unsigned long)ReadByteHDMITX_CAT(REGPktAudCTSCnt0));    //printf("N value is %5d, CTS value is %5d \n",N, CTS);      CAT_Switch_HDMITX_Bank(TX_SLV0, 0); //select bank 0    // CTS = TMDSCLK * N / ( 128 * SampleFreq )     // SampleFreq = TMDSCLK * N / (128*CTS)         if (CTS == 0)    {
        hdmi_dbg_print("CTS is 0, ERROR \n");        return -1;    }    // to avoid float, use shift    temp_sample =
(long)((VModeTables[info->tv_mode].PixClk * 10000) << 8) / (128 *
CTS);    SampleFreq = (temp_sample * N) >> 8; //currVideoPixelClock/CTS ;    if (SampleFreq > 30000 && SampleFreq <= 38000)    {        // SampleFreq = 32000 ;        info->audiopath_sf = FS_32K;        hdmi_dbg_print("set audio sampling frequency to 32k\n");        fs = 3;        // FS_32K_flag++;
   }    else if (SampleFreq < 46000)// 44.1KHz
   {        // SampleFreq = 44100 ;        hdmi_dbg_print("set audio sampling frequency to 44.1k\n");        info->audiopath_sf = FS_44K1;        fs = 0;        // FS_44_1K_flag++;
   }
   else if (SampleFreq < 68100)// 48KHz    {        // SampleFreq = 48000 ;        info->audiopath_sf = FS_48K;        hdmi_dbg_print("set audio sampling frequency to 48k\n");        fs = 2;        // FS_48K_flag++;
   }    else if (SampleFreq < 92100)// 88.2 KHz
   {
        // SampleFreq = 88200 ;        info->audiopath_sf = FS_88K2;        hdmi_dbg_print("set audio sampling frequency to 88.2k\n");        fs = 8;        // FS_88_2K_flag++;
   }    else if (SampleFreq < 136200)// 96KHz
   {
        // SampleFreq = 96000 ;
       info->audiopath_sf = FS_96K;        hdmi_dbg_print("set audio sampling frequency to 96k\n");        fs = 0xa;        // FS_96K_flag++;
   }    else if (SampleFreq < 184200)// 176.4KHz
   {        // SampleFreq = 176400 ;        info->audiopath_sf = FS_176K4;        hdmi_dbg_print("set audio sampling frequency to 176.4k\n");        fs = 0xc;        // FS_176_8K_flag++;        
   }    else if (SampleFreq < 240200)// 192KHz
   {
        // SampleFreq = 192000 ;        info->audiopath_sf = FS_192K;        hdmi_dbg_print("set audio sampling frequency to 196k\n");        fs = 0xe;        // FS_192K_flag++;
   }    else    {        // SampleFreq = 44100 ;        info->audiopath_sf = FS_44K1;        hdmi_dbg_print("force to set audio sampling frequency to 44.1k\n");        fs = 0;    }    CAT6611_bPendingAudioAdjust = 0;    CAT_SetNCTS(info);	// set N, CTS by new generated clock.    CAT_Switch_HDMITX_Bank(TX_SLV0, 1);// adjust the new fs in channel status registers    WriteByteHDMITX_CAT(REG_AUDCHST_CA_FS, ((ReadByteHDMITX_CAT(REG_AUDCHST_CA_FS)) & 0xf0) | fs);// choose clock    fs = ~fs;// OFS is the one's complement of FS    uc = (ReadByteHDMITX_CAT(REG_AUDCHST_OFS_WL)) & 0x0f;    uc |= fs << 4;    WriteByteHDMITX_CAT(REG_AUDCHST_OFS_WL, uc);    CAT_Switch_HDMITX_Bank(TX_SLV0, 0);    return 0;
}

// Valid bit should be set to ¡®1¡¯ if the corresponding audio channel maps to the NLPCM audio source.void CAT_SetNonPCMAudio(Hdmi_info_para_t* info){    unsigned char reg;    unsigned char NLPCM;    NLPCM = (info->audiopath_format & 0xf0) >> 4;//bit[4:6]: 0 - PCM format; 1 - AC3 format,    CAT_Switch_HDMITX_Bank(TX_SLV0, 1);    reg = (ReadByteHDMITX_CAT(REG_AUDCHST_MODE)) & ~B_AUD_NLPCM;//bit2: Nonlinear PCM data. or linear PCM data.    reg |= (NLPCM) ? B_AUD_NLPCM : 0;    WriteByteHDMITX_CAT(REG_AUDCHST_MODE, reg);// 2 audio channel without pre-emphasis, if NumChannel set it as 1.    CAT_Switch_HDMITX_Bank(TX_SLV0, 0);
} //The valid bits for audio channel 8/7, 6/5, 4/3 are defined in regE4[2:0]. //The valid bit for channel 2/1 is defined in reg191[2]. //Valid bit should be set to ¡®1¡¯ if the corresponding audio channel maps to the NLPCM audio source.//SPDIF: the channel status setting for SPDIF audio source can be selected as user defined mode or //SPDIF mirror mode by regE3[4]. In user defined mode is the channel status setting is defined in reg191 to reg199. //In SPDIF mirror mode, hardware extracts channel status information from input SPDIF data stream automatically.static int CAT_SetAudioFormat(Hdmi_info_para_t * info, unsigned char AudioEnable, unsigned char AudioCatCode) {    unsigned char fs;    unsigned char SWL;    unsigned char bChannelSwap;    unsigned char SourceValid;    unsigned char SoruceNum;    unsigned char bOutputAudioMode = 0x41;// bit6:use full packet as default; bit0 = 1: 32-bit I2S
   unsigned char audio_fifo_flag = 0xe4;// default mapping. Audio FIFO 3 from audio source 3; Audio FIFO 2 from audio source 2; Audio FIFO 1 from audio source 1; Audio FIFO 0 from audio source 0
//    if( ReadByteHDMITX_CAT(REG_INT_CTRL) & B_IDENT_6612 )//    {//        // if 6612, use external MCLK sampling instead of oversampling//        fs = ReadByteHDMITX_CAT(REG_CLK_CTRL0) ;//        fs &= ~(B_AUTO_OVER_SAMPLING_CLOCK|M_EXT_MCLK_SEL|B_EXT_MCLK) ;//        fs |= B_EXT_256FS|B_EXT_MCLK ;    //6612//        WriteByteHDMITX_CAT(REG_CLK_CTRL0, fs) ;//    }        switch (info->audiopath_sf)    {        case FS_32K:            fs = 3;            break;        case FS_44K1:            fs = 0;            break;        case FS_48K:            fs = 2;            break;        case FS_88K2:            fs = 8;            break;                case FS_96K:            fs = 0xa;            break;        case FS_176K4:            fs = 0x0c;            break;        case FS_192K:            fs = 0xe;            break;        default:            fs = 0;            info->audiopath_sf = FS_44K1;            break;    }
	    //defined audio channel : source 0    if (((info->audiopath_sl) & 0xf) > 5)//more than 6 channels    {        // SourceValid = B_AUD_ERR2FLAT | B_AUD_S3VALID | B_AUD_S2VALID | B_AUD_S1VALID | B_AUD_SPXFLAT_SRC0 | B_AUD_SPXFLAT_SRC1 | B_AUD_SPXFLAT_SRC2 | B_AUD_SPXFLAT_SRC3; // only 6 channel.                SourceValid = B_AUD_ERR2FLAT | B_AUD_S3VALID | B_AUD_S2VALID | B_AUD_S1VALID;        SoruceNum = 4;        bOutputAudioMode |= B_AUD_FULLPKT;//full packet mode        AudioEnable |= B_AUD_EN_I2S0 | B_AUD_EN_I2S1 | B_AUD_EN_I2S2 | B_AUD_EN_I2S3;    }    else if (((info->audiopath_sl) & 0xf) > 3)//more than 4 channels
   {
        // SourceValid = B_AUD_ERR2FLAT | B_AUD_S2VALID | B_AUD_S1VALID | B_AUD_SPXFLAT_SRC0 | B_AUD_SPXFLAT_SRC1 | B_AUD_SPXFLAT_SRC2; // only 6 channel.                SourceValid = B_AUD_ERR2FLAT | B_AUD_S2VALID | B_AUD_S1VALID;        SoruceNum = 3;        bOutputAudioMode |= B_AUD_FULLPKT;        AudioEnable |= B_AUD_EN_I2S0 | B_AUD_EN_I2S1 | B_AUD_EN_I2S2;//full packet mode
   }    else if (((info->audiopath_sl) & 0xf) > 1)//more than 2 channels 
   {        // SourceValid = B_AUD_ERR2FLAT | B_AUD_S1VALID | B_AUD_SPXFLAT_SRC0 | B_AUD_SPXFLAT_SRC1; // only 4 channel.                SourceValid = B_AUD_ERR2FLAT | B_AUD_S1VALID;        SoruceNum = 2;        bOutputAudioMode |= B_AUD_FULLPKT;	//full packet mode        AudioEnable |= B_AUD_EN_I2S0 | B_AUD_EN_I2S1;    }    else    {        // SourceValid = B_AUD_ERR2FLAT | B_AUD_SPXFLAT_SRC0; // only two channel.        SourceValid = B_AUD_ERR2FLAT;// only two channel.        SoruceNum = 1;
        bOutputAudioMode &= ~B_AUD_FULLPKT;//disable full packet mode        AudioEnable |= B_AUD_EN_I2S0;
    }    if (AudioEnable & B_AUD_SPDIF)    {        AudioEnable &=
~(B_AUD_EN_I2S3 | B_AUD_EN_I2S2 | B_AUD_EN_I2S1);        AudioEnable |= B_AUD_EN_I2S0;    }    AudioEnable &= ~(M_AUD_SWL | B_SPDIFTC);    switch ((info->audiopath_sl & 0xf0) >> 4)//choose the Sample Size
   {        case 0:            hdmi_dbg_print("(audio sampling Size is 16bit\n");            SWL = AUD_SWL_16;            AudioEnable |= M_AUD_16BIT;            break;        case 1:            hdmi_dbg_print("(audio sampling Size is 18bit\n");            SWL = AUD_SWL_18;            AudioEnable |= M_AUD_18BIT;            break;        case 2:            hdmi_dbg_print("(audio sampling Size is 20bit\n");            SWL = AUD_SWL_20;            AudioEnable |= M_AUD_20BIT;            break;        case 3:            hdmi_dbg_print("(audio sampling Size is 24bit\n");            SWL = AUD_SWL_24;            AudioEnable |= M_AUD_24BIT;            break;        default:            hdmi_dbg_print("(audio sampling Size is error\n");            return -1;    }    CAT_Switch_HDMITX_Bank(TX_SLV0, 0);    if (ReadByteHDMITX_CAT(REG_INT_CTRL) & B_IDENT_6612)    {        bChannelSwap = 0;    }    else    {        // if cat6611, regE3[3:0] bit '1' for no swap.        bChannelSwap = 0x0F;    }    WriteByteHDMITX_CAT(REG_AUDIO_CTRL0, AudioEnable & 0xF0);// disable audio channel before audio enabled.    WriteByteHDMITX_CAT(REG_SW_RST, (ReadByteHDMITX_CAT(REG_SW_RST)) & (~(B_AUD_RST | B_AREF_RST)));//enable audio(bit4==0: Software Audio clock base signal reset, bit2: Audio FIFO reset.)    WriteByteHDMITX_CAT(REG_AUDIO_FIFOMAP, audio_fifo_flag);    //SPDIF: the channel status setting for SPDIF audio source can be selected as user defined mode or     //SPDIF mirror mode by regE3[4]. In user defined mode is the channel status setting is defined in reg191 to reg199.     //In SPDIF mirror mode, hardware extracts channel status information from input SPDIF data stream automatically. 
   WriteByteHDMITX_CAT(REG_AUDIO_CTRL3,
((AudioEnable & B_AUD_SPDIF) ? B_CHSTSEL : 0) |
bChannelSwap);
    //If the input I2S source use 32-bit to represent an audio sample, the regE4[0] should be set to ¡®1¡¯.     //Since the SPDIF source always use 32-bit sub-frame, this bit regE4[0] should also be set to ¡®1¡¯.     if (((info->audiopath_format & 0x0f) == 0) || (bOutputAudioMode & 0x1))//B_AUD_SPDIF        SourceValid |= B_AUD_S1VALID;    WriteByteHDMITX_CAT(REG_AUD_SRCVALID_FLAT, SourceValid);    //bOutputAudioMode |= 0x0f;    WriteByteHDMITX_CAT(REG_AUDIO_CTRL1, bOutputAudioMode);// regE1 should be loaded from ROM image. suggested to be 0x41    //the channel status setting for I2S audio source is defined in reg191 to reg199.    CAT_Switch_HDMITX_Bank(TX_SLV0, 1);    WriteByteHDMITX_CAT(REG_AUDCHST_MODE, ((ReadByteHDMITX_CAT(REG_AUDCHST_MODE)) & B_AUD_NLPCM) | ((((info->audiopath_sl) & 0xf) == 0) ? B_AUD_MONO : 0));	// 1 audio channel without pre-emphasis, if NumChannel set it as 1.    WriteByteHDMITX_CAT(REG_AUDCHST_CAT, AudioCatCode);    WriteByteHDMITX_CAT(REG_AUDCHST_SRCNUM, SoruceNum);    WriteByteHDMITX_CAT(REG_AUD0CHST_CHTNUM, 0x21);    WriteByteHDMITX_CAT(REG_AUD1CHST_CHTNUM, 0x43);    WriteByteHDMITX_CAT(REG_AUD2CHST_CHTNUM, 0x65);    WriteByteHDMITX_CAT(REG_AUD3CHST_CHTNUM, 0x87);    WriteByteHDMITX_CAT(REG_AUDCHST_CA_FS, 0x00 | fs);	// choose clock    fs = ~fs;// OFS is the one's complement of FS    WriteByteHDMITX_CAT(REG_AUDCHST_OFS_WL, (fs << 4) | SWL);    CAT_Switch_HDMITX_Bank(TX_SLV0, 0);    WriteByteHDMITX_CAT(REG_AUDIO_CTRL0, AudioEnable);    bAudioPendingCounter = 10;    bAudioEnableSetting = AudioEnable;    bPendingAudio = 1;    CAT6611_bPendingAudioAdjust = 0;    return 0;
}
void CAT_EnableAudioOutput(Hdmi_info_para_t * info) {    unsigned char bAudioChannelstatus;    hdmi_dbg_print("EnableAudioOutput \n");    switch (((info->audiopath_sl) & 0xf))    {        case 8:        case 7:            bAudioChannelstatus = 0xF;            hdmi_dbg_print("audio  channel is 7.1 or 8 \n");            break;        case 6:        case 5:        case 4:            bAudioChannelstatus = 0x7;            hdmi_dbg_print("audio  channel is 4.1 or 5.1 or 6.1 \n");            break;        case 3:        case 2:            bAudioChannelstatus = 0x3;            hdmi_dbg_print("audio  channel is 3.0 or 4.0 \n");            break;        case 1:        case 0:        default:            bAudioChannelstatus = 0x1;            hdmi_dbg_print("audio  channel is 1 or 2.0 \n");            break;    }    if ((info->audiopath_format & 0x0f) == 0)//B_AUD_SPDIF    {        bAudioChannelstatus |= B_AUD_SPDIF;        hdmi_dbg_print("SPDIF audio \n");    }    else if ((info->audiopath_format & 0x0f) == 1)    {        hdmi_dbg_print("I2S audio \n");    }    CAT_SetNCTS(info);    CAT_SetAudioFormat(info, bAudioChannelstatus, 0);    return;
}
void CAT_DisableAudioOutput(void) {    unsigned char uc;    hdmi_dbg_print("DisableAudioOutput \n");    CAT_Switch_HDMITX_Bank(TX_SLV0, 0);    uc = ReadByteHDMITX_CAT(REG_AUDIO_CTRL0);    uc &= 0xC0;    WriteByteHDMITX_CAT(REG_AUDIO_CTRL0, uc);    uc = ReadByteHDMITX_CAT(REG_SW_RST);    WriteByteHDMITX_CAT(REG_SW_RST, uc | B_AUD_RST | B_AREF_RST);//disable audio(bit4:Software Audio clock base signal reset, bit2: Audio FIFO reset.)    bPendingAudio = 0;    CAT6611_bPendingAudioAdjust = 0;
} void CAT_SetAudioChannel(Hdmi_info_para_t * info) {    if (bPendingAudio)    {        if ((ReadByteHDMITX_CAT(REG_SW_RST) & (B_AUD_RST | B_AREF_RST))
== 0)        {            CAT_Switch_HDMITX_Bank(TX_SLV0, 0);            if (bAudioEnableSetting & B_AUD_SPDIF)            {                if (ReadByteHDMITX_CAT(REG_CLK_STATUS2) &
 B_OSF_LOCK)                {                    CAT_AdjustAudioSampleClock(info);                }

               else                {                    return;                }            }            else            {                if (bAudioPendingCounter)                {                    bAudioPendingCounter--;                    return;                }                else                {                    CAT_AdjustAudioSampleClock(info);                }            }
            WriteByteHDMITX_CAT(REG_AUDIO_CTRL0, bAudioEnableSetting);            bPendingAudio = 0;        }
    }    if (CAT6611_bPendingAudioAdjust)    {
        CAT_AdjustAudioSampleClock(info);    }
}


