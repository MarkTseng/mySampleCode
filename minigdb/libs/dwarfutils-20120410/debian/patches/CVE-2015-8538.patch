Description: Fix for CVE-2015-8538 (OOB read)
Origin: http://sourceforge.net/p/libdwarf/code/ci/da724a0bc5eec8e9ec0b0cb0c238a80e34466459/
Bug-Debian: https://bugs.debian.org/807817

--- a/libdwarf/dwarf_abbrev.c
+++ b/libdwarf/dwarf_abbrev.c
@@ -126,6 +126,10 @@
         attr = (Dwarf_Half) utmp2;
         DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
         attr_form = (Dwarf_Half) utmp2;
+        if (!_dwarf_valid_form_we_know(dbg,attr_form,attr)) {
+            _dwarf_error(NULL, error, DW_DLE_UNKNOWN_FORM);
+            return DW_DLV_ERROR;
+        }
 
         if (attr != 0)
             (labbr_count)++;
--- a/libdwarf/dwarf_die_deliv.c
+++ b/libdwarf/dwarf_die_deliv.c
@@ -657,13 +657,15 @@
     Dwarf_Byte_Ptr info_ptr = 0;
     Dwarf_Byte_Ptr abbrev_ptr = 0;
     Dwarf_Word abbrev_code = 0;
-    Dwarf_Abbrev_List abbrev_list;
+    Dwarf_Abbrev_List abbrev_list = 0;
     Dwarf_Half attr = 0;
     Dwarf_Half attr_form = 0;
     Dwarf_Unsigned offset = 0;
     Dwarf_Word leb128_length = 0;
     Dwarf_Unsigned utmp = 0;
     Dwarf_Debug dbg = 0;
+    Dwarf_Error error = 0;
+    int lres = 0;
 
     info_ptr = die_info_ptr;
     DECODE_LEB128_UWORD(info_ptr, utmp);
@@ -673,8 +675,8 @@
     }
 
 
-    abbrev_list = _dwarf_get_abbrev_for_code(cu_context, abbrev_code);
-    if (abbrev_list == NULL) {
+    lres = _dwarf_get_abbrev_for_code(cu_context, abbrev_code, &abbrev_list, &error);
+    if (lres == DW_DLV_ERROR || lres == DW_DLV_NO_ENTRY) {
         return (NULL);
     }
     dbg = cu_context->cc_dbg;
@@ -833,6 +835,7 @@
     Dwarf_Byte_Ptr die_info_end = 0;
     Dwarf_Word abbrev_code = 0;
     Dwarf_Unsigned utmp = 0;
+    int lres = 0;
     /* Since die may be NULL, we rely on the input argument. */
     Dwarf_Debug_InfoTypes dis = is_info? &dbg->de_info_reading: 
         &dbg->de_types_reading; 
@@ -962,9 +965,13 @@
         return (DW_DLV_NO_ENTRY);
     }
     ret_die->di_abbrev_code = abbrev_code;
-    ret_die->di_abbrev_list =
-        _dwarf_get_abbrev_for_code(ret_die->di_cu_context, abbrev_code);
-    if (ret_die->di_abbrev_list == NULL ) {
+    lres = _dwarf_get_abbrev_for_code(ret_die->di_cu_context, abbrev_code,
+                                      &ret_die->di_abbrev_list, error);
+    if (lres == DW_DLV_ERROR) {
+        dwarf_dealloc(dbg, ret_die, DW_DLA_DIE);
+        return lres;
+    }
+    if (lres == DW_DLV_NO_ENTRY) {
         dwarf_dealloc(dbg, ret_die, DW_DLA_DIE);
         _dwarf_error(dbg, error, DW_DLE_DIE_ABBREV_LIST_NULL);
         return (DW_DLV_ERROR);
@@ -1073,12 +1080,19 @@
         return DW_DLV_NO_ENTRY;
     }
     ret_die->di_abbrev_code = abbrev_code;
-    ret_die->di_abbrev_list =
-        _dwarf_get_abbrev_for_code(die->di_cu_context, abbrev_code);
-    if (ret_die->di_abbrev_list == NULL) {
-        dwarf_dealloc(dbg, ret_die, DW_DLA_DIE);
-        _dwarf_error(dbg, error, DW_DLE_DIE_BAD);
-        return (DW_DLV_ERROR);
+
+    {
+        int lres = _dwarf_get_abbrev_for_code(die->di_cu_context, abbrev_code,
+                                              &ret_die->di_abbrev_list, error);
+        if (lres == DW_DLV_ERROR) {
+            dwarf_dealloc(dbg, ret_die, DW_DLA_DIE);
+            return lres;
+        }
+        if (lres == DW_DLV_NO_ENTRY) {
+            dwarf_dealloc(dbg, ret_die, DW_DLA_DIE);
+            _dwarf_error(dbg, error, DW_DLE_DIE_BAD);
+            return (DW_DLV_ERROR);
+        }
     }
 
     *caller_ret_die = ret_die;
@@ -1111,6 +1125,7 @@
     Dwarf_Byte_Ptr info_ptr = 0;
     Dwarf_Unsigned abbrev_code = 0;
     Dwarf_Unsigned utmp = 0;
+    int lres = 0;
     Dwarf_Debug_InfoTypes dis = 0;
 
 
@@ -1201,9 +1216,13 @@
         return DW_DLV_NO_ENTRY;
     }
     die->di_abbrev_code = abbrev_code;
-    die->di_abbrev_list =
-        _dwarf_get_abbrev_for_code(cu_context, abbrev_code);
-    if (die->di_abbrev_list == NULL) {
+    lres = _dwarf_get_abbrev_for_code(cu_context, abbrev_code,
+                                      &die->di_abbrev_list, error);
+    if (lres == DW_DLV_ERROR) {
+        dwarf_dealloc(dbg, die, DW_DLA_DIE);
+        return lres;
+    }
+    if (lres == DW_DLV_NO_ENTRY) {
         dwarf_dealloc(dbg, die, DW_DLA_DIE);
         _dwarf_error(dbg, error, DW_DLE_DIE_ABBREV_LIST_NULL);
         return (DW_DLV_ERROR);
--- a/libdwarf/dwarf_error.c
+++ b/libdwarf/dwarf_error.c
@@ -328,6 +328,7 @@
     "DW_DLE_DEBUG_TYPEOFFSET_BAD (239)",
     "DW_DLE_GNU_OPCODE_ERROR (240)",
     "DW_DLE_RELOC_INVALID (241)",
+    "DW_DLE_UNKNOWN_FORM (242) Possibly corrupt DWARF data",
 };
 
 
--- a/libdwarf/dwarf_query.c
+++ b/libdwarf/dwarf_query.c
@@ -189,14 +189,19 @@
     Dwarf_Attribute *attr_ptr = 0;
     Dwarf_Debug dbg = 0;
     Dwarf_Byte_Ptr info_ptr = 0;
+    int lres = 0;
 
     CHECK_DIE(die, DW_DLV_ERROR);
     dbg = die->di_cu_context->cc_dbg;
 
-    abbrev_list = _dwarf_get_abbrev_for_code(die->di_cu_context,
-        die->di_abbrev_list->ab_code);
-    if (abbrev_list == NULL) {
-        _dwarf_error(dbg, error, DW_DLE_DIE_ABBREV_BAD);
+    lres = _dwarf_get_abbrev_for_code(die->di_cu_context,
+                                      die->di_abbrev_list->ab_code,
+                                      &abbrev_list,error);
+    if (lres == DW_DLV_ERROR) {
+        return lres;
+    }
+    if (lres == DW_DLV_NO_ENTRY) {
+        _dwarf_error(dbg, error, DW_DLE_DIE_BAD);
         return (DW_DLV_ERROR);
     }
     abbrev_ptr = abbrev_list->ab_abbrev_ptr;
@@ -211,6 +216,10 @@
         attr = (Dwarf_Half) utmp2;
         DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
         attr_form = (Dwarf_Half) utmp2;
+        if (!_dwarf_valid_form_we_know(dbg,attr_form,attr)) {
+            _dwarf_error(dbg, error, DW_DLE_UNKNOWN_FORM);
+            return DW_DLV_ERROR;
+        }
 
         if (attr != 0) {
             new_attr =
@@ -298,10 +307,14 @@
     Dwarf_Half curr_attr = 0;
     Dwarf_Half curr_attr_form = 0;
     Dwarf_Byte_Ptr info_ptr = 0;
+    Dwarf_Error error = 0;
+    int lres = 0;
 
-    abbrev_list = _dwarf_get_abbrev_for_code(die->di_cu_context,
-        die->di_abbrev_list->ab_code);
-    if (abbrev_list == NULL) {
+    lres = _dwarf_get_abbrev_for_code(die->di_cu_context,
+                                      die->di_abbrev_list->ab_code,
+                                      &abbrev_list,
+                                      &error);
+    if (lres == DW_DLV_NO_ENTRY || lres == DW_DLV_ERROR) {
         *attr_form = 0;
         return (NULL);
     }
--- a/libdwarf/dwarf_util.c
+++ b/libdwarf/dwarf_util.c
@@ -222,6 +222,23 @@
     }
 }
 
+#define TRUE 1
+#define FALSE 0
+
+int _dwarf_valid_form_we_know (Dwarf_Debug dbg, Dwarf_Unsigned at_form, Dwarf_Unsigned at_name)
+{
+    if (at_form == 0 && at_name == 0) {
+        return TRUE;
+    }
+    if (at_name == 0) {
+        return FALSE;
+    }
+    if (at_form <= DW_FORM_ref_sig8) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
 /*  This function returns a pointer to a Dwarf_Abbrev_List_s
     struct for the abbrev with the given code.  It puts the
     struct on the appropriate hash table.  It also adds all
@@ -247,8 +264,8 @@
     never moves once allocated, so the pointer is safe to return.
 
     Returns NULL on error.  */
-Dwarf_Abbrev_List
-_dwarf_get_abbrev_for_code(Dwarf_CU_Context cu_context, Dwarf_Unsigned code)
+int _dwarf_get_abbrev_for_code(Dwarf_CU_Context cu_context, Dwarf_Unsigned code,
+                               Dwarf_Abbrev_List *list_out, Dwarf_Error *error)
 {
     Dwarf_Debug dbg = cu_context->cc_dbg;
     Dwarf_Hash_Table hash_table_base = cu_context->cc_abbrev_hash_table;
@@ -276,7 +293,7 @@
             DW_DLA_HASH_TABLE_ENTRY, 
             hash_table_base->tb_table_entry_count);
         if(! hash_table_base->tb_entries) {
-            return NULL;
+            return DW_DLV_NO_ENTRY;
         }
 
     } else if (hash_table_base->tb_total_abbrev_count >
@@ -290,7 +307,7 @@
             newht.tb_table_entry_count);
 
         if(! newht.tb_entries) {
-            return NULL;
+            return DW_DLV_NO_ENTRY;
         }
         /*  Copy the existing entries to the new table,
             rehashing each.  */
@@ -318,7 +335,8 @@
     if (hash_abbrev_entry != NULL) {
         /*  This returns a pointer to an abbrev list entry, not 
             the list itself. */
-        return (hash_abbrev_entry);
+        *list_out = hash_abbrev_entry;
+        return DW_DLV_OK;
     }
 
     abbrev_ptr = cu_context->cc_last_abbrev_ptr != NULL ?
@@ -330,22 +348,23 @@
     /*  End of abbrev's as we are past the end entirely.
         THis can happen */
     if (abbrev_ptr > end_abbrev_ptr) {
-        return (NULL);
+        return DW_DLV_NO_ENTRY;
     }
     /*  End of abbrev's for this cu, since abbrev code is 0. */
     if (*abbrev_ptr == 0) {
-        return (NULL);
+        return DW_DLV_NO_ENTRY;
     }
 
     do {
         unsigned new_hashable_val = 0;
         DECODE_LEB128_UWORD(abbrev_ptr, abbrev_code);
         DECODE_LEB128_UWORD(abbrev_ptr, abbrev_tag);
+        unsigned long abcount = 0;
 
         inner_list_entry = (Dwarf_Abbrev_List)
             _dwarf_get_alloc(cu_context->cc_dbg, DW_DLA_ABBREV_LIST, 1);
         if (inner_list_entry == NULL) {
-            return (NULL);
+            return DW_DLV_NO_ENTRY;
         }
 
         new_hashable_val = abbrev_code;
@@ -363,11 +382,17 @@
         inner_list_entry->ab_has_child = *(abbrev_ptr++);
         inner_list_entry->ab_abbrev_ptr = abbrev_ptr;
 
+        hash_table_base->tb_total_abbrev_count++;
+
         /*  Cycle thru the abbrev content, ignoring the content except
             to find the end of the content. */
         do {
             DECODE_LEB128_UWORD(abbrev_ptr, attr_name);
             DECODE_LEB128_UWORD(abbrev_ptr, attr_form);
+            if (!_dwarf_valid_form_we_know(dbg,attr_form,attr_name)) {
+                _dwarf_error(dbg,error,DW_DLE_UNKNOWN_FORM);
+                return DW_DLV_ERROR;
+            }
         } while (attr_name != 0 && attr_form != 0);
 
         /*  We may have fallen off the end of content,  that is not
@@ -377,7 +402,11 @@
         *abbrev_ptr != 0 && abbrev_code != code);
 
     cu_context->cc_last_abbrev_ptr = abbrev_ptr;
-    return (abbrev_code == code ? inner_list_entry : NULL);
+    if(abbrev_code == code) {
+        *list_out = inner_list_entry;
+        return DW_DLV_OK;
+    }
+    return DW_DLV_NO_ENTRY;
 }
 
 
--- a/libdwarf/dwarf_util.h
+++ b/libdwarf/dwarf_util.h
@@ -300,9 +300,8 @@
 
 
 
-Dwarf_Abbrev_List
-_dwarf_get_abbrev_for_code(Dwarf_CU_Context cu_context,
-    Dwarf_Unsigned code);
+int _dwarf_get_abbrev_for_code(Dwarf_CU_Context cu_context, Dwarf_Unsigned code,
+                               Dwarf_Abbrev_List *list_out, Dwarf_Error *error);
 
 
 /* return 1 if string ends before 'endptr' else
--- a/libdwarf/libdwarf.h
+++ b/libdwarf/libdwarf.h
@@ -1062,10 +1062,11 @@
 #define DW_DLE_DEBUG_TYPEOFFSET_BAD            239
 #define DW_DLE_GNU_OPCODE_ERROR                240
 #define DW_DLE_RELOC_INVALID                   241
+#define DW_DLE_UNKNOWN_FORM                    242
 
 
     /* DW_DLE_LAST MUST EQUAL LAST ERROR NUMBER */
-#define DW_DLE_LAST        241
+#define DW_DLE_LAST        242
 #define DW_DLE_LO_USER     0x10000
 
     /*  Taken as meaning 'undefined value', this is not
