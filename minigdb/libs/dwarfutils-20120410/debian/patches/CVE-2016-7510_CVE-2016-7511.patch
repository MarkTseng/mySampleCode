Description: CVE-2016-7510, CVE-2016-7511
Author: David Anderson (dandelot)
Source: https://sourceforge.net/p/libdwarf/code/ci/3767305debcba8bd7e1c483ae48c509d25399252
Last-Update: 2016-09-24

--- a/libdwarf/dwarf_ranges.c
+++ b/libdwarf/dwarf_ranges.c
@@ -49,6 +49,16 @@
    Dwarf_Ranges cur;
 };
 
+static void
+free_allocated_ranges( struct ranges_entry *base) 
+{
+     struct ranges_entry *cur = 0; 
+     struct ranges_entry *next = 0; 
+    for ( cur = base ; cur ; cur = next ) {
+        next = cur->next;
+        free(cur);
+    }
+}
 
 #define MAX_ADDR ((address_size == 8)?0xffffffffffffffffULL:0xffffffff)
 int dwarf_get_ranges_a(Dwarf_Debug dbg,
@@ -88,15 +98,25 @@
     beginrangeptr = rangeptr;
 
     for(;;) {
-        struct ranges_entry * re = calloc(sizeof(struct ranges_entry),1);
+        struct ranges_entry * re = 0;
+
+        if (rangeptr == section_end) {
+            break;
+        }
+        if (rangeptr  > section_end) {
+            free_allocated_ranges(base);
+            _dwarf_error(dbg, error, DW_DLE_DEBUG_RANGES_OFFSET_BAD);
+            return (DW_DLV_ERROR);
+            break;
+        }
+        re = calloc(sizeof(struct ranges_entry),1);
         if(!re) {
+            free_allocated_ranges(base);
             _dwarf_error(dbg, error, DW_DLE_DEBUG_RANGES_OUT_OF_MEM);
             return (DW_DLV_ERROR);
         }
-        if(rangeptr  >= section_end) {
-            return (DW_DLV_NO_ENTRY);
-        }
         if((rangeptr + (2*address_size)) > section_end) {
+            free_allocated_ranges(base);
             _dwarf_error(dbg, error, DW_DLE_DEBUG_RANGES_OFFSET_BAD);
             return (DW_DLV_ERROR);
         }
@@ -129,6 +149,7 @@
     ranges_data_out =   (Dwarf_Ranges *)
     _dwarf_get_alloc(dbg,DW_DLA_RANGES,entry_count);
     if(!ranges_data_out) {
+        free_allocated_ranges(base);
         _dwarf_error(dbg, error, DW_DLE_DEBUG_RANGES_OUT_OF_MEM);
         return (DW_DLV_ERROR);
     }
@@ -141,8 +162,10 @@
         struct ranges_entry *r = curre;
         *ranges_data_out = curre->cur;
         curre = curre->next;
-        free(r);
     }
+    /* ASSERT: curre == NULL */
+    free_allocated_ranges(base);
+    base = 0;
     /* Callers will often not care about the bytes used. */
     if(bytecount) {
         *bytecount = rangeptr - beginrangeptr;
