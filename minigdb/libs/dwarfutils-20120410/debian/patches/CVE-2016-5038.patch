Description: Fix for CVE-2016-5038 (OOB read in dwarf_get_macro_startend_file())
Author: Fabian Wolff <fabi.wolff@arcor.de>
Origin: backport, https://sourceforge.net/p/libdwarf/code/ci/82d8e007851805af0dcaaff41f49a2d48473334b/

--- a/libdwarf/dwarf_die_deliv.c
+++ b/libdwarf/dwarf_die_deliv.c
@@ -655,7 +655,7 @@
     Dwarf_Bool * has_die_child)
 {
     Dwarf_Byte_Ptr info_ptr = 0;
-    Dwarf_Byte_Ptr abbrev_ptr = 0;
+    Dwarf_Byte_Ptr abbrev_ptr = 0, abbrev_end = 0;
     Dwarf_Word abbrev_code = 0;
     Dwarf_Abbrev_List abbrev_list = 0;
     Dwarf_Half attr = 0;
@@ -684,12 +684,14 @@
     *has_die_child = abbrev_list->ab_has_child;
 
     abbrev_ptr = abbrev_list->ab_abbrev_ptr;
+    abbrev_end = (&dbg->de_debug_abbrev)->dss_data
+        + (&dbg->de_debug_abbrev)->dss_size;
     do {
         Dwarf_Unsigned utmp2;
 
-        DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
+        DECODE_LEB128_UWORD_CK(abbrev_ptr, utmp2,dbg,&error,abbrev_end);
         attr = (Dwarf_Half) utmp2;
-        DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
+        DECODE_LEB128_UWORD_CK(abbrev_ptr, utmp2,dbg,&error,abbrev_end);
         attr_form = (Dwarf_Half) utmp2;
         if (attr_form == DW_FORM_indirect) {
             Dwarf_Unsigned utmp6;
@@ -1032,7 +1034,7 @@
         _dwarf_next_die_info_ptr(die_info_ptr, die->di_cu_context,
             die_info_end, NULL, false,
             &has_die_child);
-    if (die_info_ptr == NULL) {
+    if ((die_info_ptr == NULL) || (die_info_ptr == (void *) 1)) {
         _dwarf_error(dbg, error, DW_DLE_NEXT_DIE_PTR_NULL);
         return (DW_DLV_ERROR);
     }
--- a/libdwarf/dwarf_error.c
+++ b/libdwarf/dwarf_error.c
@@ -332,6 +332,7 @@
     "DW_DLE_READ_LITTLEENDIAN_ERROR (243)",
     "DW_DLE_READ_BIGENDIAN_ERROR (244)",
     "DW_DLE_ARANGES_HEADER_ERROR (245)",
+    "DW_DLE_LEB_IMPROPER (246)",
 };
 
 
--- a/libdwarf/dwarf_leb.c
+++ b/libdwarf/dwarf_leb.c
@@ -108,6 +108,85 @@
     }
 }
 
+#define BYTESLEBMAX 10
+
+/* Decode ULEB with checking */
+int
+_dwarf_decode_u_leb128_chk(Dwarf_Small * leb128, Dwarf_Word * leb128_length,
+    Dwarf_Unsigned *outval,Dwarf_Byte_Ptr endptr)
+{
+    unsigned char byte     = 0;
+    Dwarf_Word word_number = 0;
+    Dwarf_Unsigned number  = 0;
+    Dwarf_Sword shift      = 0;
+    /*  The byte_length value will be a small non-negative integer. */
+    unsigned byte_length   = 0;
+
+    if (leb128 >=endptr) {
+        return DW_DLV_ERROR;
+    }
+    /*  The following unrolls-the-loop for the first two bytes and
+        unpacks into 32 bits to make this as fast as possible.
+        word_number is assumed big enough that the shift has a defined
+        result. */
+    if ((*leb128 & 0x80) == 0) {
+        if (leb128_length) {
+            *leb128_length = 1;
+        }
+        *outval = *leb128;
+        return DW_DLV_OK;
+    } else {
+        if ((leb128+1) >=endptr) {
+            return DW_DLV_ERROR;
+        }
+        if ((*(leb128 + 1) & 0x80) == 0) {
+            if (leb128_length) {
+                *leb128_length = 2;
+            }
+            word_number = *leb128 & 0x7f;
+            word_number |= (*(leb128 + 1) & 0x7f) << 7;
+            *outval = word_number;
+            return DW_DLV_OK;
+        }
+        /* Gets messy to hand-inline more byte checking. */
+    }
+
+    /*  The rest handles long numbers Because the 'number' may be larger
+        than the default int/unsigned, we must cast the 'byte' before
+        the shift for the shift to have a defined result. */
+    number = 0;
+    shift = 0;
+    byte_length = 1;
+    byte = *leb128;
+    for (;;) {
+        number |= ((Dwarf_Unsigned) (byte & 0x7f)) << shift;
+
+        if ((byte & 0x80) == 0) {
+            if (leb128_length) {
+                *leb128_length = byte_length;
+            }
+            *outval = number;
+            return DW_DLV_OK;
+        }
+        shift += 7;
+
+        byte_length++;
+        if (byte_length > BYTESLEBMAX) {
+            /*  Erroneous input.  */
+            if( leb128_length) {
+                *leb128_length = BYTESLEBMAX;
+            }
+            break;
+        }
+        ++leb128;
+        if ((leb128) >=endptr) {
+            return DW_DLV_ERROR;
+        }
+        byte = *leb128;
+    }
+    return DW_DLV_ERROR;
+}
+
 #define BITSINBYTE 8
 
 /*  decode SLEB */
--- a/libdwarf/dwarf_util.h
+++ b/libdwarf/dwarf_util.h
@@ -43,7 +43,19 @@
 */
 
 
-
+#define DECODE_LEB128_UWORD_CK(ptr, value,dbg,errptr,endptr) \
+    do {                                                     \
+        Dwarf_Word lu_leblen = 0;                            \
+        Dwarf_Unsigned lu_local = 0;                         \
+        int lu_res = 0;                                      \
+        lu_res = _dwarf_decode_u_leb128_chk(ptr,&lu_leblen,&lu_local,endptr); \
+        if (lu_res == DW_DLV_ERROR) {                        \
+            _dwarf_error(dbg, errptr, DW_DLE_LEB_IMPROPER);  \
+            return DW_DLV_ERROR;                             \
+        }                                                    \
+        value = lu_local;                                    \
+        ptr += lu_leblen;                                    \
+    } while (0)
 
 /*
     Decodes unsigned leb128 encoded numbers.
--- a/libdwarf/libdwarf.h
+++ b/libdwarf/libdwarf.h
@@ -1066,10 +1066,11 @@
 #define DW_DLE_READ_LITTLEENDIAN_ERROR         243
 #define DW_DLE_READ_BIGENDIAN_ERROR            244
 #define DW_DLE_ARANGES_HEADER_ERROR            245
+#define DW_DLE_LEB_IMPROPER                    246
 
 
     /* DW_DLE_LAST MUST EQUAL LAST ERROR NUMBER */
-#define DW_DLE_LAST        245
+#define DW_DLE_LAST        246
 #define DW_DLE_LO_USER     0x10000
 
     /*  Taken as meaning 'undefined value', this is not
--- a/libdwarf/dwarf_query.c
+++ b/libdwarf/dwarf_query.c
@@ -181,7 +181,7 @@
     Dwarf_Word i = 0;
     Dwarf_Half attr = 0;
     Dwarf_Half attr_form = 0;
-    Dwarf_Byte_Ptr abbrev_ptr = 0;
+    Dwarf_Byte_Ptr abbrev_ptr = 0, abbrev_end = 0;
     Dwarf_Abbrev_List abbrev_list = 0;
     Dwarf_Attribute new_attr = 0;
     Dwarf_Attribute head_attr = NULL;
@@ -205,6 +205,7 @@
         return (DW_DLV_ERROR);
     }
     abbrev_ptr = abbrev_list->ab_abbrev_ptr;
+    abbrev_end = (&dbg->de_debug_abbrev)->dss_data + (&dbg->de_debug_abbrev)->dss_size;
 
     info_ptr = die->di_debug_ptr;
     SKIP_LEB128_WORD(info_ptr);
@@ -212,9 +213,9 @@
     do {
         Dwarf_Unsigned utmp2;
 
-        DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
+        DECODE_LEB128_UWORD_CK(abbrev_ptr, utmp2,dbg,error,abbrev_end);
         attr = (Dwarf_Half) utmp2;
-        DECODE_LEB128_UWORD(abbrev_ptr, utmp2);
+        DECODE_LEB128_UWORD_CK(abbrev_ptr, utmp2,dbg,error,abbrev_end);
         attr_form = (Dwarf_Half) utmp2;
         if (!_dwarf_valid_form_we_know(dbg,attr_form,attr)) {
             _dwarf_error(dbg, error, DW_DLE_UNKNOWN_FORM);
