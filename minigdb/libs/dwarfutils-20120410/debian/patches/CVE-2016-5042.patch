Description: Fix for CVE-2016-5042
 In dwarf_get_aranges_list() an invalid count will iterate, reading
 from memory addresses that increase till it all fails.
Origin: backport, https://sourceforge.net/p/libdwarf/code/ci/98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f

--- a/libdwarf/dwarf_arange.c
+++ b/libdwarf/dwarf_arange.c
@@ -102,13 +102,12 @@
         /* Length of current set of aranges. */
         Dwarf_Unsigned length = 0;
         Dwarf_Small remainder = 0;
-        Dwarf_Small *arange_ptr_past_end = 0;
         Dwarf_Unsigned range_entry_size = 0;
-
         int local_length_size;
 
         /*REFERENCED*/ /* Not used in this instance of the macro */
         int local_extension_size = 0;
+        Dwarf_Small *end_this_arange = 0;
 
         header_ptr = arange_ptr;
 
@@ -116,11 +115,19 @@
         READ_AREA_LENGTH(dbg, length, Dwarf_Unsigned,
             arange_ptr, local_length_size,
             local_extension_size);
-        arange_ptr_past_end = arange_ptr + length;
+
+        if ((length + local_length_size + local_extension_size) >
+            dbg->de_debug_aranges.dss_size) {
+            _dwarf_error(dbg, error, DW_DLE_ARANGES_HEADER_ERROR);
+            return DW_DLV_ERROR;
+        }
+
+        end_this_arange = arange_ptr + length;
 
 
-        READ_UNALIGNED(dbg, version, Dwarf_Half,
-            arange_ptr, sizeof(Dwarf_Half));
+        READ_UNALIGNED_CK(dbg, version, Dwarf_Half,
+                          arange_ptr, sizeof(Dwarf_Half),
+                          error,end_this_arange);
         arange_ptr += sizeof(Dwarf_Half);
         length = length - sizeof(Dwarf_Half);
         if (version != CURRENT_VERSION_STAMP) {
@@ -128,8 +135,9 @@
             return (DW_DLV_ERROR);
         }
 
-        READ_UNALIGNED(dbg, info_offset, Dwarf_Off,
-            arange_ptr, local_length_size);
+        READ_UNALIGNED_CK(dbg, info_offset, Dwarf_Off,
+                          arange_ptr, local_length_size,
+                          error, end_this_arange);
         arange_ptr += local_length_size;
         length = length - local_length_size;
         /* This applies to debug_info only, not to debug_types. */
@@ -243,14 +251,14 @@
                 DWARF2,3,4 section 7.20 
                 We stop short to avoid overrun of the end of the CU.  */
               
-        } while (arange_ptr_past_end >= (arange_ptr + range_entry_size));
+        } while (end_this_arange >= (arange_ptr + range_entry_size));
 
         /*  A compiler could emit some padding bytes here. dwarf2/3
             (dwarf4 sec 7.20) does not clearly make extra padding 
             bytes illegal. */
-        if (arange_ptr_past_end < arange_ptr) {
+        if (end_this_arange < arange_ptr) {
             char buf[200];
-            Dwarf_Unsigned pad_count = arange_ptr - arange_ptr_past_end;
+            Dwarf_Unsigned pad_count = arange_ptr - end_this_arange;
             Dwarf_Unsigned offset = arange_ptr - arange_ptr_start;
             snprintf(buf,sizeof(buf),"DW_DLE_ARANGE_LENGTH_BAD."
                 " 0x%" DW_PR_XZEROS DW_PR_DUx 
@@ -259,9 +267,9 @@
                 pad_count, offset);
             dwarf_insert_harmless_error(dbg,buf);
         }
-        /*  For most compilers, arange_ptr == arange_ptr_past_end at
+        /*  For most compilers, arange_ptr == end_this_arange at
             this point. But not if there were padding bytes */
-        arange_ptr = arange_ptr_past_end;
+        arange_ptr = end_this_arange;
     } while (arange_ptr <
         dbg->de_debug_aranges.dss_data + dbg->de_debug_aranges.dss_size);
 
--- a/libdwarf/dwarf_error.c
+++ b/libdwarf/dwarf_error.c
@@ -329,6 +329,9 @@
     "DW_DLE_GNU_OPCODE_ERROR (240)",
     "DW_DLE_RELOC_INVALID (241)",
     "DW_DLE_UNKNOWN_FORM (242) Possibly corrupt DWARF data",
+    "DW_DLE_READ_LITTLEENDIAN_ERROR (243)",
+    "DW_DLE_READ_BIGENDIAN_ERROR (244)",
+    "DW_DLE_ARANGES_HEADER_ERROR (245)",
 };
 
 
--- a/libdwarf/dwarf_util.h
+++ b/libdwarf/dwarf_util.h
@@ -130,6 +130,18 @@
         dest = (desttype)_ltmp;  \
     } while (0)
 
+#define READ_UNALIGNED_CK(dbg,dest,desttype, source, length,error,endptr) \
+    do {                                                                  \
+        BIGGEST_UINT _ltmp = 0;                                           \
+        Dwarf_Byte_Ptr readend = source+length;                           \
+        if (readend > endptr) {                                           \
+            _dwarf_error(dbg, error, DW_DLE_READ_LITTLEENDIAN_ERROR);     \
+            return DW_DLV_ERROR;                                          \
+        }                                                                 \
+        dbg->de_copy_word( (((char *)(&_ltmp)) + sizeof(_ltmp) - length), \
+                           source, length);                               \
+        dest = (desttype)_ltmp;                                           \
+    } while (0)
 
 /*
     This macro sign-extends a variable depending on the length.
@@ -155,6 +167,17 @@
         dest = (desttype)_ltmp;               \
     } while (0)
 
+#define READ_UNALIGNED_CK(dbg,dest,desttype, source, length,error,endptr) \
+    do {                                                                  \
+        BIGGEST_UINT _ltmp = 0;                                           \
+        Dwarf_Byte_Ptr readend = source+length;                           \
+        if (readend > endptr) {                                           \
+            _dwarf_error(dbg, error, DW_DLE_READ_BIGENDIAN_ERROR);        \
+            return DW_DLV_ERROR;                                          \
+        }                                                                 \
+        dbg->de_copy_word( (char *)(&_ltmp), source, length);             \
+        dest = (desttype)_ltmp;                                           \
+    } while (0)
 
 /*
     This macro sign-extends a variable depending on the length.
--- a/libdwarf/libdwarf.h
+++ b/libdwarf/libdwarf.h
@@ -1063,10 +1063,13 @@
 #define DW_DLE_GNU_OPCODE_ERROR                240
 #define DW_DLE_RELOC_INVALID                   241
 #define DW_DLE_UNKNOWN_FORM                    242
+#define DW_DLE_READ_LITTLEENDIAN_ERROR         243
+#define DW_DLE_READ_BIGENDIAN_ERROR            244
+#define DW_DLE_ARANGES_HEADER_ERROR            245
 
 
     /* DW_DLE_LAST MUST EQUAL LAST ERROR NUMBER */
-#define DW_DLE_LAST        242
+#define DW_DLE_LAST        245
 #define DW_DLE_LO_USER     0x10000
 
     /*  Taken as meaning 'undefined value', this is not
